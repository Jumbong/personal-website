{
  "hash": "6237a91330e3f161de53896f40a6a2c5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Missing Data Assessment\"\nsubtitle: \"\"\ndate: last-modified\nsidebar: auto\nnumber-sections: false\ntoc: true\nauthor:\n  - Jumbong Junior \n\ncategories: []\ntags: [\"MCAR\", \"MAR\", \"MNAR\", \"missing data\"]\ntitle-block-banner: false\nbibliography: references.bib\nformat: \n  html: \n    mainfont: Times New Roman\n    fontsize: 1.1em\n\njupyter: python3\nnotice: |\n    @wasserman2004all \n---\n\n\n## Assessing the MCAR Assumption\n\n::: {#857462ee .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\n# --- Reproducibility ---\nnp.random.seed(42)\n\n# --- Parameters ---\nn = 10000\n\n# --- Utility Functions ---\ndef generate_continuous(mean, std, size, missing_rate=0.0):\n    \"\"\"Generate a continuous variable with optional MCAR missingness.\"\"\"\n    values = np.random.normal(loc=mean, scale=std, size=size)\n    if missing_rate > 0:\n        mask = np.random.rand(size) < missing_rate\n        values[mask] = np.nan\n    return values\n\ndef generate_categorical(levels, probs, size, missing_rate=0.0):\n    \"\"\"Generate a categorical variable with optional MCAR missingness.\"\"\"\n    values = np.random.choice(levels, size=size, p=probs).astype(float)\n    if missing_rate > 0:\n        mask = np.random.rand(size) < missing_rate\n        values[mask] = np.nan\n    return values\n\n# --- Variable Generation ---\nvariables = {\n    \"cont_mcar\": generate_continuous(mean=100, std=20, size=n, missing_rate=0.20),\n    \"cat_mcar\": generate_categorical(levels=[0, 1], probs=[0.7, 0.3], size=n, missing_rate=0.10),\n    \"cont_full\": generate_continuous(mean=50, std=10, size=n),\n    \"cat_full\": generate_categorical(levels=[0, 1], probs=[0.6, 0.4], size=n),\n    \"target\": np.random.choice([0, 1], size=n, p=[0.5, 0.5])\n}\n\n# --- Build DataFrame ---\ndf = pd.DataFrame(variables)\n\n# --- Display Summary ---\nprint(df.head())\nprint(\"\\nMissing value counts:\")\nprint(df.isnull().sum())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    cont_mcar  cat_mcar  cont_full  cat_full  target\n0  109.934283       0.0  58.674277       0.0       1\n1         NaN       0.0  41.178927       0.0       1\n2         NaN       1.0  39.448885       1.0       1\n3         NaN       1.0  47.594213       0.0       1\n4   95.316933       0.0  58.287854       1.0       0\n\nMissing value counts:\ncont_mcar    1952\ncat_mcar      993\ncont_full       0\ncat_full        0\ntarget          0\ndtype: int64\n```\n:::\n:::\n\n\n::: {#23d691f9 .cell execution_count=2}\n``` {.python .cell-code}\nfrom sklearn.model_selection import train_test_split\nimport pandas as pd\n\ndef stratified_split(df, strat_vars, test_size=0.3, random_state=None):\n    \"\"\"\n    Split a DataFrame into train and test sets with stratification\n    based on one or multiple variables.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The input dataset.\n    strat_vars : list or str\n        Column name(s) used for stratification.\n    test_size : float, default=0.3\n        Proportion of the dataset to include in the test split.\n    random_state : int, optional\n        Random seed for reproducibility.\n\n    Returns\n    -------\n    train_df : pandas.DataFrame\n        Training set.\n    test_df : pandas.DataFrame\n        Test set.\n    \"\"\"\n    # Ensure strat_vars is a list\n    if isinstance(strat_vars, str):\n        strat_vars = [strat_vars]\n\n    # Create a combined stratification key\n    strat_key = df[strat_vars].astype(str).fillna(\"MISSING\").agg(\"_\".join, axis=1)\n\n    # Perform stratified split\n    train_df, test_df = train_test_split(\n        df,\n        test_size=test_size,\n        stratify=strat_key,\n        random_state=random_state\n    )\n\n    return train_df, test_df\n\n\n# --- Exemple d'utilisation ---\n# Stratification sur cat_mcar, cat_full et target\ntrain_df, test_df = stratified_split(df, strat_vars=[\"cat_mcar\", \"cat_full\", \"target\"], test_size=0.3, random_state=42)\n\nprint(f\"Train size: {train_df.shape[0]}  ({len(train_df)/len(df):.1%})\")\nprint(f\"Test size:  {test_df.shape[0]}  ({len(test_df)/len(df):.1%})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrain size: 7000  (70.0%)\nTest size:  3000  (30.0%)\n```\n:::\n:::\n\n\n::: {#74039f25 .cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# --- Step 1: Train/Test Split with Stratification ---\ntrain_df, test_df = stratified_split(\n    df,\n    strat_vars=[\"cat_mcar\", \"cat_full\", \"target\"],\n    test_size=0.3,\n    random_state=42\n)\n\n# --- Step 2: Create the R indicator on the training set ---\ntrain_df = train_df.copy()\ntrain_df[\"R_cont_mcar\"] = np.where(train_df[\"cont_mcar\"].isnull(), 0, 1)\n\n# --- Step 3: Prepare the data for comparison ---\ndf_obs = pd.DataFrame({\n    \"cont_full\": train_df.loc[train_df[\"R_cont_mcar\"] == 1, \"cont_full\"],\n    \"Group\": \"Observed (R=1)\"\n})\n\ndf_miss = pd.DataFrame({\n    \"cont_full\": train_df.loc[train_df[\"R_cont_mcar\"] == 0, \"cont_full\"],\n    \"Group\": \"Missing (R=0)\"\n})\n\ndf_all = pd.concat([df_obs, df_miss])\n\n# --- Step 4: KS Test before plotting ---\nfrom scipy.stats import ks_2samp\nstat, p_value = ks_2samp(\n    train_df.loc[train_df[\"R_cont_mcar\"] == 1, \"cont_full\"],\n    train_df.loc[train_df[\"R_cont_mcar\"] == 0, \"cont_full\"]\n)\n\n# --- Step 5: Visualization with KS result ---\nplt.figure(figsize=(8, 6))\nsns.boxplot(\n    x=\"Group\", \n    y=\"cont_full\", \n    data=df_all,\n    palette=\"Set2\",\n    width=0.6,\n    fliersize=3\n)\n\n# Add red diamonds for means\nmeans = df_all.groupby(\"Group\")[\"cont_full\"].mean()\nfor i, m in enumerate(means):\n    plt.scatter(i, m, color=\"red\", marker=\"D\", s=50, zorder=3, label=\"Mean\" if i == 0 else \"\")\n\n# Title and KS test result\nplt.title(\"Distribution of cont_full by Missingness of cont_mcar (Train Set)\",\n          fontsize=14, weight=\"bold\")\n\n# Add KS result as text box\ntextstr = f\"KS Statistic = {stat:.3f}\\nP-value = {p_value:.3f}\"\nplt.gca().text(\n    0.05, 0.95, textstr,\n    transform=plt.gca().transAxes,\n    fontsize=10,\n    verticalalignment='top',\n    bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"white\", alpha=0.8)\n)\n\nplt.ylabel(\"cont_full\", fontsize=12)\nplt.xlabel(\"\")\nsns.despine()\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/v8/l5q0bw4s2ln17s59y7cc86rm0000gn/T/ipykernel_25747/38423988.py:38: FutureWarning:\n\n\n\nPassing `palette` without assigning `hue` is deprecated and will be removed in v0.14.0. Assign the `x` variable to `hue` and set `legend=False` for the same effect.\n\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](missing_data_assessment_files/figure-html/cell-4-output-2.png){width=702 height=508}\n:::\n:::\n\n\n::: {#70d54bd2 .cell execution_count=4}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import chi2_contingency\n\n# --- Step 1: Build contingency table on the TRAIN set ---\ncontingency_table = pd.crosstab(train_df[\"R_cont_mcar\"], train_df[\"cat_full\"])\nchi2, p_value, dof, expected = chi2_contingency(contingency_table)\n\n# --- Step 2: Compute proportions for each group ---\n# --- Recompute proportions but flip the axes ---\nprops = contingency_table.div(contingency_table.sum(axis=1), axis=0)\n\n# Transform for plotting: Group (R) on x-axis, Category as hue\ndf_props = props.reset_index().melt(\n    id_vars=\"R_cont_mcar\",\n    var_name=\"Category\",\n    value_name=\"Proportion\"\n)\n\n# Map R values to clear labels\ndf_props[\"Group\"] = df_props[\"R_cont_mcar\"].map({1: \"Observed (R=1)\", 0: \"Missing (R=0)\"})\n\n# --- Plot: Group on x-axis, bars show proportions of each category ---\nsns.set_theme(style=\"whitegrid\")\nplt.figure(figsize=(8,6))\n\nsns.barplot(\n    x=\"Group\", y=\"Proportion\", hue=\"Category\",\n    data=df_props, palette=\"Set2\"\n)\n\n# Title and Chi² result\nplt.title(\"Proportion of cat_full by Observed/Missing Status of cont_mcar (Train Set)\",\n          fontsize=14, weight=\"bold\")\n\n# Add Chi² result as a text box\ntextstr = f\"Chi² = {chi2:.3f}, p = {p_value:.3f}\"\nplt.gca().text(\n    0.05, 0.95, textstr,\n    transform=plt.gca().transAxes,\n    fontsize=10,\n    verticalalignment='top',\n    bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"white\", alpha=0.8)\n)\n\nplt.xlabel(\"Observed / Missing Group (R)\")\nplt.ylabel(\"Proportion\")\nplt.legend(title=\"cat_full Category\")\nsns.despine()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](missing_data_assessment_files/figure-html/cell-5-output-1.png){width=702 height=531}\n:::\n:::\n\n\n",
    "supporting": [
      "missing_data_assessment_files"
    ],
    "filters": [],
    "includes": {}
  }
}