{
  "hash": "68025b05c36095d1b58eb96eb43c3cd1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Fourrier Transformation\"\nsubtitle: \"\"\ndate: last-modified\nsidebar: auto\nnumber-sections: false\ntoc: true\nauthor:\n  - Jumbong Junior \n\ncategories: []\ntags: [\"\"]\ntitle-block-banner: false\nbibliography: references.bib\nformat: \n  html: \n    mainfont: Times New Roman\n    fontsize: 1.1em\n\njupyter: python3\nnotice: |\n    @balac2011transformee @cooley1965algorithm @epstein2005well el2013parametric\n---\n\n\n# Introduction\n\nWhen we were in our third year of the Risk Management program at an engineering school, we took a course on the calibration of stochastic processes. To assess our understanding, the instructor gave us a selection of academic papers and asked us to choose one, study it thoroughly, and reproduce its results.\n\nWe chose the paper by @el2013parametric, which proposes a method for estimating the parameters of stochastic volatility models based on contrast minimization and deconvolution.\n\nTo do so, we had to implement an optimization algorithm that relies on the Fourier transform to evaluate the following function:\n\n\n$$\n\\hat{f}(\\nu) = \\int_{-\\infty}^{+\\infty} f_{\\theta}(t) e^{-2i\\pi\\nu t} dt\n$$\noù $f_{\\theta}(y) = \\frac{1}{2\\sqrt{\\pi}} \\left(\\frac{-i \\phi y \\gamma^2 \\exp\\left(-\\frac{y^2}{2} \\gamma^2\\right)}{\\exp\\left(-i \\mathcal{E} y\\right) 2^{iy} \\Gamma\\left(\\frac{1}{2} + iy\\right)}\\right)$ andd $\\theta = (\\phi, \\gamma, \\mathcal{E})$ a vector of parameters to estimate. \n\n\n\nTo compute the Fourier transform of $f$, @el2013parametric uses the left Riemann sum (rectangle quadrature) method implemented in MATLAB and suggests that using the Fast Fourier Transform (FFT) algorithm could accelerate the computation of the Fourier transform.\n\nWe decided to reproduce the paper using Python. Implementing the left rectangle quadrature method was straightforward, and we initially believed that the `scipy.fft` and `numpy.fft` libraries would allow us to compute the Fourier transform of $f$ using the FFT algorithm.\n\nHowever, we were surprised to discover that these functions do not compute the Fourier transform of a continuous function but rather the discrete Fourier transform (DFT) of a finite sequence. The plot below illustrates this observation.\n\n::: {#3439b158 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, fftshift\n\n# Define the function f(t) = exp(-pi * t^2)\ndef f(t):\n    return np.exp(-np.pi * t**2)\n\n# Parameters\nN = 1024\nT = 1.0 / 64\nt = np.linspace(-N/2*T, N/2*T, N, endpoint=False)\ny = f(t)\n\n# FFT with scipy\nyf_scipy = fftshift(fft(y)) * T\nxf = fftshift(fftfreq(N, T))\nFT_exact = np.exp(-np.pi * xf**2)\n\n# FFT with numpy\nyf_numpy = np.fft.fftshift(np.fft.fft(y)) * T\nxf_numpy = np.fft.fftshift(np.fft.fftfreq(N, T))\n\n# Plot with subplot_mosaic\nfig, axs = plt.subplot_mosaic([[\"scipy\", \"numpy\"]], figsize=(7, 5), layout=\"constrained\", sharey=True)\n\n# Scipy FFT\naxs[\"scipy\"].plot(xf, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[\"scipy\"].plot(xf, np.real(yf_scipy), 'r--', linewidth=1, label='FFT (scipy)')\naxs[\"scipy\"].set_xlim(-6, 6)\naxs[\"scipy\"].set_ylim(-1, 1)\naxs[\"scipy\"].set_title(\"Scipy FFT\")\naxs[\"scipy\"].set_xlabel(\"Frequency\")\naxs[\"scipy\"].set_ylabel(\"Amplitude\")\naxs[\"scipy\"].legend()\naxs[\"scipy\"].grid(False)\n\n# NumPy FFT\naxs[\"numpy\"].plot(xf_numpy, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[\"numpy\"].plot(xf_numpy, np.real(yf_numpy), 'b--', linewidth=1, label='FFT (numpy)')\naxs[\"numpy\"].set_xlim(-6, 6)\naxs[\"numpy\"].set_title(\"NumPy FFT\")\naxs[\"numpy\"].set_xlabel(\"Frequency\")\naxs[\"numpy\"].legend()\naxs[\"numpy\"].grid(False)\n\nplt.suptitle(\"Comparison of FFT Implementations vs. Exact Fourier Transform\", fontsize=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-2-output-1.png){width=683 height=491}\n:::\n:::\n\n\nThis motivation led us to write this article to explain how to compute the Fourier transform of a function using both the left Riemann sum (rectangle quadrature) method and the Fast Fourier Transform (FFT) algorithm.\n\nThe paper by @el2013parametric illustrates an application of the Fourier transform in finance and ecology. Beyond these domains, the Fourier transform plays a key role in spectral analysis, solving partial differential equations, evaluating integrals, and computing series sums. It is widely used in physics, engineering, and signal processing.\n\nIn the literature, several articles discuss approximating the Fourier transform and implementing it using numerical methods. However, we have not found a source as clear and comprehensive as the one by @balac2011transformee, which proposes a quadrature-based approach to compute the Fourier transform and explains how to use the FFT algorithm to compute the discrete Fourier transform.\n\nWe use @balac2011transformee as our primary reference to show how to approximate the Fourier transform in Python using both methods: the left rectangle quadrature method and the Fast Fourier Transform (FFT) algorithm.\n\n\n\n\n\n\n## Definition and Properties of the Fourier Transform\n\nWe adopt the framework presented by @balac2011transformee to define the Fourier transform of a function $f$ and to introduce its properties.\n\nThe functions considered belong to the space of integrable functions, denoted $L^1(\\mathbb{R,K})$, consisting of all functions  $f:\\mathbb{R} \\to \\mathbb{K}$ [where $\\mathbb{K}$ is either $\\mathbb{R}$ or $\\mathbb{C}$]. These functions are integrable in the sense of Lebesgue, meaning that the integral of their absolute value is finite:\n$$\n\\int_{-\\infty}^{+\\infty} |f(t)| dt < +\\infty.\n$$\n\n\nSo, for a function $f$ to belong to $L^1(\\mathbb{R}, \\mathbb{K})$, the product $f(t) \\cdot e^{-2i\\pi\\nu t}$ must also be integrable for all $\\nu \\in \\mathbb{R}$. In that case, the **Fourier transform** of $f$, denoted $\\hat{f}$ (or sometimes $\\mathcal{F}(f)$), is defined for all $\\nu \\in \\mathbb{R}$ by:\n\n$$\n\\hat{f}(\\nu) = \\int_{-\\infty}^{+\\infty}\nf(t) \\, e^{-2i\\pi\\nu t} \\, dt.\n$$\n\n\nThe key takeaway is that the Fourier transform $\\hat{f}$ of a function $f$ is a complex-valued, linear function that depends on the frequency $\\nu$. If $f \\in L^1(\\mathbb{R})$, is real-valued and even, then $\\hat{f}$ is also real-valued and even. Conversely, if $f$ is real-valued and odd, then $\\hat{f}$ is purely imaginary and odd as well.\n\nFor some functions, the Fourier transform can be computed analytically. For example, for the function $f : t \\in \\mathbb{R} \\mapsto \\mathbb{1}_{[-\\frac{a}{2}, \\frac{a}{2}]}(t)$, the Fourier transform is given by:\n$$\n\\hat{f} : \\nu \\in \\mathbb{R} \\mapsto a sinc(a \\pi \\nu)\n$$\nwhere $sinc(t) = \\frac{\\sin(t)}{t}$ is the sinc function.\n\nHowever, for many functions, the Fourier transform cannot be computed analytically. In such cases, we can use numerical methods to approximate it. We will explore these numerical approaches in the following sections of this article.\n\n## How to approximate the Fourier Transform?\n\nThe Fourier transform of a function $f$ is defined as an integral over the entire real line. However, for the functions that are integral in the sense of lebesgue and that have a practical applications tend to 0 as $|t| \\to +\\infty$. And we can approximate the Fourier transform by integrating over a finite interval $[-T, T]$. If the lenght of the interval is large enough, or if the function decays quickly when t tends to infinity, this approximation will be accurate.\n\n$$\n\\hat{f}(\\nu) \\approx \\int_{-T}^{T} f(t) e^{-2i\\pi\\nu t} dt\n$$\n\nIn his article, @balac2011transformee goes further by showing that approximating the Fourier transform involves three key mathematical tools:\n\n* **Fourier series**, in the context of a periodic signal,\n* **The Fourier transform**, for non-periodic signals,\n* **The discrete Fourier transform**, for discrete signals.\n\nFor each of these tools, computing the Fourier transform essentially comes down to evaluating the following integral:\n$$\n\\hat{f}(\\nu) \\approx \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t) e^{-2i\\pi\\nu t} dt\n$$\nI recommend reading his article for more details on these three tools. Next, we will focus on the numerical computation of the Fourier transform using quadrature methods, a technique for performing numerical integration.\n \n## Numerical Computation of the Fourier Transform\n\nWe show that computing the Fourier transform of a function $f$ consists to approximating it by the integral the following integral over the interval $[-\\frac{T}{2}, \\frac{T}{2}]$:\n$$\n\\boxed{\n\\underbrace{\n  \\int_{-\\infty}^{+\\infty} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\hat{f}(\\nu)}\n\\approx\n\\underbrace{\n  \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\tilde{S}(\\nu)}\n}\n$$\n\nwhere T is a large enough number such that the integral converges. Une valeur approchée of the integral $\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt$ can be computed using quadrature methods. In the next section, we will approximate the integral using the quadrature method of rectangles à gauche.\n\n## Quadrature method of left Rectangles\n\nTo compute the integral $\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt$, using the quadrature method of left rectangles, we follow these steps:\n\n1. **Discretization of the Interval:**: We divide the interval $[-\\frac{T}{2}, \\frac{T}{2}]$ into $N$ uniform subintervals of length $h_t = \\frac{T}{N}$. The discretization points[eft endpoints of the rectangles] in the interval are given by:\n\n$$\nt_k = -\\frac{T}{2} + k \\cdot h_t, \\quad k = 0, 1, \\ldots, N-1.\n$$\n\n2. **Approximation of the Integral**: Using the Chasles relation, we can approximate the integral $\\tilde{S}(\\nu)$ as follows:\n\n$$\n\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt = \\sum_{k=0}^{N-1}  \\int_{t_k}^{t_{k+1}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt.\n$$\n\nBy taking into account that we have $t_{k+1} - t_k = h_t$, and $t_k = -\\frac{T}{2} + k \\cdot h_t = T(\\frac{k}{N} - \\frac{1}{2})$, we can rewrite the integral as:\n$$\n\\boxed{\n\\tilde{S}(\\nu) = \\sum_{k=0}^{N-1} f(t_k) e^{-2\\pi i \\nu t_k} h_t.\n}\n$$\n\nWe call it the **quadrature method of left rectangles** because it uses the **left endpoint** $t_k$ of each subinterval to approximate the value of the function $f(t)$ at that point.\n\n3. **Final Formula**: The final formula for the approximation of the Fourier transform is given by:\n\n$$\n\\boxed{\n\\forall \\nu \\in \\mathbb{R} \\quad\n\\underbrace{\n\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\tilde{S}(\\nu)}\n\\approx\n\\underbrace{\n\\frac{T}{n} e^{i \\pi \\nu T} \\sum_{k=0}^{n-1} f_k\\, e^{-2 i \\pi \\nu T k / n}\n}_{=\\,\\tilde{S}_n(\\nu)}\n\\quad \\text{où } f_k = f\\left( \\frac{2k - n}{2n} T \\right).\n}\n$$\n\n### Implementation of the left rectangle quadrature method in Python.\n\n\nThe function `tfquad` below implements the **left rectangle quadrature method** to compute the **Fourier transform** of a function `f` at a given frequency `nu`.\n\n::: {#5bdb3399 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\ndef tfquad(f, nu, n, T):\n    \"\"\"\n    Computes the Fourier transform of a function f at frequency nu\n    using left Riemann sum quadrature over the interval [-T/2, T/2].\n\n    Parameters:\n    ----------\n    f : callable\n        The function to transform. Must accept a NumPy array as input.\n    nu : float\n        The frequency at which to evaluate the Fourier transform.\n    n : int\n        Number of quadrature points.\n    T : float\n        Width of the time window [-T/2, T/2].\n\n    Returns:\n    -------\n    tfnu : complex\n        Approximated value of the Fourier transform at frequency nu.\n    \"\"\"\n    k = np.arange(n)\n    t_k = (k / n - 0.5) * T\n    weights = np.exp(-2j * np.pi * nu * T * k / n)\n    prefactor = (T / n) * np.exp(1j * np.pi * nu * T)\n\n    return prefactor * np.sum(f(t_k) * weights)\n```\n:::\n\n\nWe can also use SciPy’s `quad` function to define the **Fourier transform** of a function `f` at a given frequency `nu`. The function `tf_integral` below implements this approach. It uses numerical integration to compute the Fourier transform of `f` over the interval $[-T/2, T/2]$.\n\n::: {#ca11143a .cell execution_count=3}\n``` {.python .cell-code}\nfrom scipy.integrate import quad\n\ndef tf_integral(f, nu, T):\n    \"\"\"Compute FT of f at frequency nu over [-T/2, T/2] using scipy quad.\"\"\"\n    real_part = quad(lambda t: np.real(f(t) * np.exp(-2j * np.pi * nu * t)), -T/2, T/2)[0]\n    imag_part = quad(lambda t: np.imag(f(t) * np.exp(-2j * np.pi * nu * t)), -T/2, T/2)[0]\n    return real_part + 1j * imag_part\n```\n:::\n\n\n::: {#fdd2f87e .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ----- Function Definitions -----\n\ndef f(t):\n    \"\"\"Indicator function on [-1, 1].\"\"\"\n    return np.where(np.abs(t) <= 1, 1.0, 0.0)\n\ndef exact_fourier_transform(nu):\n    \"\"\"Analytical FT of the indicator function over [-1, 1].\"\"\"\n    # f̂(ν) = ∫_{-1}^{1} e^{-2πiνt} dt = 2 * sinc(2ν)\n    return 2 * np.sinc(2 * nu)\n\n\n# ----- Computation -----\n\nT = 2.0\nn = 32\nnu_vals = np.linspace(-6, 6, 500)\nexact_vals = exact_fourier_transform(nu_vals)\ntfquad_vals = np.array([tfquad(f, nu, n, T) for nu in nu_vals])\n\n# Compute the approximation using scipy integral\ntf_integral_vals = np.array([tf_integral(f, nu, T) for nu in nu_vals])\n```\n:::\n\n\n::: {#c4d2a5ad .cell execution_count=5}\n``` {.python .cell-code}\nfig, axs = plt.subplot_mosaic([[\"tfquad\", \"quad\"]], figsize=(7, 5), layout=\"constrained\")\n\n# Plot using tfquad implementation\naxs[\"tfquad\"].plot(nu_vals, np.real(exact_vals), 'b-', linewidth=2, label=r'$\\hat{f}$ (exact)')\naxs[\"tfquad\"].plot(nu_vals, np.real(tfquad_vals), 'r--', linewidth=1.5, label=r'approximation $\\hat{S}_n$')\naxs[\"tfquad\"].set_title(\"TF avec tfquad (rectangles)\")\naxs[\"tfquad\"].set_xlabel(r'$\\nu$')\naxs[\"tfquad\"].grid(False)\naxs[\"tfquad\"].set_ylim(-0.5, 2.1)\n\n# Plot using scipy.integrate.quad\naxs[\"quad\"].plot(nu_vals, np.real(exact_vals), 'b-', linewidth=2, label=r'$\\hat{f}$ (quad)')\naxs[\"quad\"].plot(nu_vals, np.real(tf_integral_vals), 'r--', linewidth=1.5, label=r'approximation $\\hat{S}_n$')\naxs[\"quad\"].set_title(\"TF avec scipy.integrate.quad\")\naxs[\"quad\"].set_xlabel(r'$\\nu$')\naxs[\"quad\"].set_ylabel('Amplitude')\naxs[\"quad\"].grid(False)\naxs[\"quad\"].set_ylim(-0.5, 2.1)\n\n\n\n# --- Global legend below the plots ---\n# Take handles from one subplot only (assumes labels are consistent)\nhandles, labels = axs[\"quad\"].get_legend_handles_labels()\nfig.legend(handles, labels,\n           loc='lower center', bbox_to_anchor=(0.5, -0.05),\n           ncol=3, frameon=False)\n\nplt.suptitle(\"Comparison of FFT Implementations vs. Exact Fourier Transform\", fontsize=14)\n\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-6-output-1.png){width=683 height=513}\n:::\n:::\n\n\nWe are now able to compute the Fourier transform of a function using the **left rectangle quadrature method**. Let's take a closer look at the characteristics and limitations of this approximation.\n\n\n## Characterizing the approximation using the left rectangle quadrature method\n\n### The approximation of the Fourier transform $\\hat{f}$ using the **left rectangle quadrature method** exhibits an **oscillatory behavior** by nature.\n\n@balac2011transformee highlights that the Fourier transform $\\hat{f}$ of the function $f$ is inherently **oscillatory**. This behavior arises from the **complex exponential term** $e^{-2\\pi i \\nu t}$ in the integral definition of the transform.\n\nTo illustrate this, the figure below shows the function\n\n$$\nf : t \\in \\mathbb{R} \\mapsto e^{-t^2} \\in \\mathbb{R}\n$$\n\nalong with the **real and imaginary parts** of its Fourier transform\n\n$$\n\\hat{f} : \\nu \\in \\mathbb{R} \\mapsto \\hat{f}(\\nu) \\in \\mathbb{C},\n$$\n\nevaluated at $\\nu = \\frac{5}{2}$.\n\nAlthough $f$ is smooth, we clearly observe **strong oscillations** in $\\hat{f}$, highlighting the influence of the exponential kernel.\n\n::: {#64d4d3da .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnu = 5 / 2\nt1 = np.linspace(-8, 8, 1000)\nt2 = np.linspace(-4, 4, 1000)\n\nf = lambda t: np.exp(-t**2)\nphi = lambda t: f(t) * np.exp(-2j * np.pi * nu * t)\n\nf_vals = f(t1)\nphi_vals = phi(t2)\n\n# Plot\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\n\naxs[0].plot(t1, f_vals, 'k', linewidth=2)\naxs[0].set_xlim(-8, 8)\naxs[0].set_ylim(0, 1)\naxs[0].set_title(r\"$f(t) = e^{-t^2}$\")\naxs[0].grid(True)\n\naxs[1].plot(t2, np.real(phi_vals), 'b', label=r\"$\\Re(\\phi)$\", linewidth=2)\naxs[1].plot(t2, np.imag(phi_vals), 'r', label=r\"$\\Im(\\phi)$\", linewidth=2)\naxs[1].set_xlim(-4, 4)\naxs[1].set_ylim(-1, 1)\naxs[1].set_title(r\"$\\phi(t) = f(t)e^{-2i\\pi\\nu t}$, $\\nu=5/2$\")\naxs[1].legend()\naxs[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-7-output-1.png){width=950 height=373}\n:::\n:::\n\n\nThese rapid variations can create difficulties in the **numerical approximation** of the Fourier transform using quadrature methods, even when a large number of points $n$ is used. One way to overcome this issue is by using the **Fast Fourier Transform (FFT)** algorithm.\n\n##  The approximation obtained using the left rectangle quadrature method is periodic in nature.\n\nWe observe that even if the function $f$ is **not periodic**, its Fourier transform approximation $\\hat{f}$ appears **periodic**. In fact, the function $\\hat{S}_n$, resulting from the quadrature method, is periodic with period\n\n$$\n\\Delta \\nu = \\frac{n}{T}.\n$$\n$$\n\\forall \\nu \\in \\mathbb{R} \\quad \n\\widehat{S}_n\\left(\\nu + \\frac{n}{T} \\right)\n= \\frac{T}{n} e^{i\\pi \\nu T} \\sum_{k=0}^{n-1} f_k \\, e^{-2i\\pi\\left(\\nu + \\frac{n}{T} \\right)T \\frac{k}{n}}\n= \\frac{T}{n} e^{i\\pi \\nu T} \\sum_{k=0}^{n-1} f_k \\, e^{-2i\\pi \\nu T \\frac{k}{n}} \\underbrace{e^{-2i\\pi k}}_{=1}\n$$\n\n$$\n\\phantom{\\forall \\nu \\in \\mathbb{R} \\quad \n\\widehat{S}_n\\left(\\nu + \\frac{n}{T} \\right)}\n= \\frac{T}{n} e^{i\\pi \\nu T} \\sum_{k=0}^{n-1} f_k \\, e^{-2i\\pi \\nu T \\frac{k}{n}} = \\widehat{S}_n(\\nu).\n$$\n\nThis periodicity of $\\hat{S}_n$ implies that it is **not possible to compute the Fourier transform** for all frequencies $\\nu \\in \\mathbb{R}$ using the quadrature method when the parameters $T$ and $n$ are fixed.\nIn fact, it becomes **impossible to compute $\\hat{f}(\\nu)$** accurately when\n\n$$\n|\\nu| \\geq \\nu_{\\text{max}},\n$$\n\nwhere $\\nu_{\\text{max}} = \\frac{n}{T}$ is the **maximum frequency** that can be resolved due to the periodic nature of $\\hat{S}_n$.\n\nAs a result, in practice, **to compute the Fourier transform for large frequencies**, one must increase either the time window $T$ or the number of points $n$.\n\nFurthermore, by evaluating the error in approximating $\\hat{f}(\\nu)$ using the left rectangle quadrature method, we find that the approximation is reliable **at frequency $\\nu$** when the following condition holds:\n\n$$\n|\\nu| \\ll \\frac{n}{T}\n$$\n\n\n$$\n\\frac{\\nu T}{n} \\ll 1.\n$$\n\n@epstein2005well shows that when using the **Fast Fourier Transform (FFT)** algorithm, it is possible to accurately compute the Fourier transform of a function $f$ for all frequencies $\\nu \\in \\mathbb{R}$, even when $\\frac{\\nu T}{n}$ is close to 1 — provided that $f$ is **piecewise continuous** and has **compact support**.\n\n## Computing the Fourier Transform at Frequency $\\nu$ Using the FFT Algorithm.\n\n\nIn this section, we denote by $\\hat{S}_n(\\nu)$ the approximation of the Fourier transform $\\hat{f}(\\nu)$ of the function $f$ at a point $\\nu \\in \\left[-\\frac{\\nu_{\\text{max}}}{2}, \\frac{\\nu_{\\text{max}}}{2}\\right]$, where $\\nu_{\\text{max}} = \\frac{n}{T}$, i.e.,\n$$\n\\boxed{\n\\hat{f}(\\nu) \\approx \\hat{S}_n(\\nu) = \\frac{T}{n} e^{i\\pi \\nu T} \\sum_{k=0}^{n-1} f_k\\, e^{-2 i \\pi \\nu T k / n}.\n}\n$$\n\n\nWe now present the Fourier transform algorithm used to approximate $\\hat{f}(\\nu)$. We will not go into the details of the Fast Fourier Transform (FFT) algorithm in this article.  @balac2011transformee provides a simplified explanation of the FFT, and for more in-depth technical details, we recommend the original article by @cooley1965algorithm.\n\nWhat is important to understand is that the use of the FFT algorithm to approximate the Fourier transform of a function $f$ is based on the result shown by @epstein2005well, which states that when $\\hat{S}_n(\\nu)$ is evaluated at the frequencies $\\nu_j = \\frac{j}{T}$ for $j = 0, 1, \\dots, n - 1$, it gives a good approximation of the continuous Fourier transform $\\hat{f}(\\nu)$.\n\nMoreover, $\\hat{S}_n$ is known to be periodic. This periodicity gives a symmetric role to the indices $j \\in \\{0, 1, \\dots, n - 1\\}$ and $k \\in \\{-\\frac{n}{2}, -\\frac{n}{2} + 1, \\dots, -1\\}$. In fact, the values of the Fourier transform of $f$ over the interval $\\left[ -\\frac{\\nu_{\\text{max}}}{2}, \\frac{\\nu_{\\text{max}}}{2} \\right]$ can be derived from the values of $\\hat{S}_n$ at the points $\\nu_j = \\frac{j}{T}$, for $j = 0, 1, \\dots, n - 1$, as follows:\n\n\n\n$$\n\\widehat{S}_n(\\nu'_j) = \\frac{T}{n} (-1)^j \\sum_{k=0}^{n-1} f_k\\, e^{-2i\\pi j \\frac{k}{n}} \n= \n\\begin{cases}\n\\widehat{S}_n(\\nu_j) & \\text{si } j \\in \\left\\{0, \\dots, \\frac{n}{2} - 1 \\right\\} \\\\\n\\widehat{S}_n(\\nu_{j-n}) & \\text{si } j \\in \\left\\{ \\frac{n}{2}, \\dots, n-1 \\right\\}\n\\end{cases}\n$$\n\n$$\n\\text{où on a exploité la relation} \\quad\ne^{-2i\\pi j \\frac{k}{n}} = e^{-2i\\pi (j-n) \\frac{k}{n}} \\times \\underbrace{e^{-2i\\pi k}}_{=1} \n= e^{-2i\\pi (j-n) \\frac{k}{n}} \n\\quad \\text{pour } j \\in \\left\\{ \\frac{n}{2}, \\dots, n-1 \\right\\}.\n$$\n\n\n\nThis relationship shows that we can compute the Fourier transform $\\hat{S}_n\\left( \\frac{j}{T} \\right)$ for $j = -\\frac{n}{2}, \\ldots, \\frac{n}{2} - 1$. Moreover, when $n$ is a power of 2, it can be shown that the computation becomes faster [see @balac2011transformee]. This process is known as the Fast Fourier Transform (FFT).\n\nTo summarize, we have shown that the Fourier transform of the function $f$ can be approximated over the interval $\\left[-\\frac{T}{2}, \\frac{T}{2}\\right]$ at the frequencies $\\nu_j = \\frac{j}{T}$ for $j = -\\frac{n}{2}, \\ldots, \\frac{n}{2} - 1$, where $n = 2^m$ for some integer $m \\geq 0$, by applying the FFT algorithm as follows:\n\n* Construct the finite sequence $F$ of values $f\\left( \\frac{2k - n}{2n} T \\right)$ for $k = 0, 1, \\ldots, n - 1$.\n\n* Compute the discrete Fourier transform $\\hat{F}$ of the sequence $F$ using the Fast Fourier Transform (FFT) algorithm, which is given by\n\n  $$\n  \\hat{F}_j = \\sum_{k=0}^{n-1} f_k \\, e^{-2i\\pi \\frac{jk}{n}}, \\quad \\text{for } j = 0, 1, \\ldots, n-1.\n  $$\n\n* Reindex and symmetrize the values to span $j = -\\frac{n}{2}, \\ldots, -1$.\n\n* Multiply each value in the array by $\\frac{T}{n} (-1)^{j-1}$, where $j \\in \\{1, \\ldots, n\\}$.\n\nThis yields an array corresponding to the values of the Fourier transform $\\hat{f}(\\nu_j)$, with $\\nu_j = \\frac{j}{T}$ for $j = -\\frac{n}{2}, \\ldots, \\frac{n}{2} - 1$.\n\nThe following Python function `tffft` implements these steps to compute the Fourier transform of a given function.\n\n::: {#1d7f3cd8 .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.fft import fft, fftshift\n\ndef tffft(f, T, n):\n    \"\"\"\n    Calcule la transformée de Fourier approchée d'une fonction f à support dans [-T/2, T/2],\n    en utilisant l’algorithme FFT.\n\n    Paramètres\n    ----------\n    f : callable\n        Fonction à transformer (doit être vectorisable avec numpy).\n    T : float\n        Largeur de la fenêtre temporelle (intervalle [-T/2, T/2]).\n    n : int\n        Nombre de points de discrétisation (doit être une puissance de 2 pour FFT efficace).\n\n    Retours\n    -------\n    tf : np.ndarray\n        Valeurs approximées de la transformée de Fourier aux fréquences discrètes.\n    freq_nu : np.ndarray\n        Fréquences discrètes correspondantes (de -n/(2T) à (n/2 - 1)/T).\n    \"\"\"\n    h = T / n\n    t = -0.5 * T + np.arange(n) * h  # noeuds temporels\n    F = f(t)                         # échantillonnage de f\n    tf = h * (-1) ** np.arange(n) * fftshift(fft(F))  # TF approximée\n    freq_nu = -n / (2 * T) + np.arange(n) / T              # fréquences ν_j = j/T\n\n    return tf, freq_nu, t\n```\n:::\n\n\nThe following program illustrates how to compute the Fourier transform of the Gaussian function $f(t) = e^{-10t^2}$ over the interval $[-10, 10]$, using the Fast Fourier Transform (FFT) algorithm.\n\n::: {#b33ef5fd .cell execution_count=8}\n``` {.python .cell-code}\n# Paramètres\na = 10\nf = lambda t: np.exp(-a * t**2)\nT = 10\nn = 2**8  # 256\n\n# Calcul de la transformée de Fourier\ntf, nu, t = tffft(f, T, n)\n\n# Représentation graphique\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\n\naxs[0].plot(t, f(t), '-g', linewidth=3)\naxs[0].set_xlabel(\"temps\")\naxs[0].set_title(\"Fonction considérée\")\naxs[0].set_xlim(-6, 6)\naxs[0].set_ylim(-0.5, 1.1)\naxs[0].grid(True)\n\naxs[1].plot(nu, np.abs(tf), '-b', linewidth=3)\naxs[1].set_xlabel(\"fréquence\")\naxs[1].set_title(\"Transformée de Fourier\")\naxs[1].set_xlim(-15, 15)\naxs[1].set_ylim(-0.5, 1)\naxs[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-9-output-1.png){width=950 height=375}\n:::\n:::\n\n\nThe method we have just presented allows us to compute and visualize the Fourier transform of a function $f$ at discrete points $\\nu_j = \\frac{j}{T}$, for $j = -\\frac{n}{2}, \\ldots, \\frac{n}{2} - 1$, where $n$ is a power of 2. These points lie within the interval $\\left[-\\frac{n}{2T}, \\frac{n}{2T}\\right]$. However, this approach does not allow us to evaluate the Fourier transform at arbitrary points $\\nu$ in the same interval when $\\nu$ is not of the form $\\nu_j = \\frac{j}{T}$.\n\nTo compute the Fourier transform of a function $f$ at a point $\\nu$ that does not coincide with one of the sampling frequencies $\\nu_j$, interpolation methods can be used (e.g., linear, polynomial, spline interpolation, etc.). In this article, we adopt the approach proposed by @balac2011transformee, which relies on **Shannon’s interpolation theorem** to compute the Fourier transform of a function $f$ at any point $\\nu$.\n\n\n\n\n\n\n## Using Shannon's Interpolation Theorem to Compute the Fourier Transform of a Function $f$ at a Point $\\nu$\n\nQue nous dit le théorème de Shannon ?  Il nous dit que pour une fonction $g$ à bande limitée c'est-à-dire dont la transformée de Fourier $\\hat{g}$ est nulle en dehors d'un intervalle $[-\\frac{B}{2}, \\frac{B}{2}]$, on peut reconstruire la fonction $g$ à partir de ses échantillons $g_k = g\\left(\\frac{k}{B}\\right)$ pour $k \\in \\mathbb{Z}$. Si on note $\\nu_c$ le plus petit réel positif tel que $\\hat{g}$ est nulle en déhors de l'intervalle $[-2 \\pi \\nu_c, 2 \\pi \\nu_c]$, alors on a la formule d'interpolation de Shannon :\nPour tout $t \\in \\mathbb{R}$, et $\\alpha$ un réel positif, vérifiant $\\alpha \\geq \\frac{1}{2 \\nu_c}$, on a :\n\n$$\ng(t) = \\sum_{k \\in \\mathbb{Z}} g(k\\alpha)\\, \\text{sinc}\\left(\\frac{\\pi}{\\alpha}(t - k\\alpha)\\right)\n$$\n\noù $\\text{sinc}(x) = \\frac{\\sin(x)}{x}$ est la fonction sinus cardinal sinc.\n\n@balac2011transformee montre que lorsque la fonction $f$ est à support borné dans un intervalle $[-T/2, T/2]$, on peut utiliser le théorème d'interpolation de Shannon pour calculer la transformée de Fourier $\\hat{f}(\\nu)$ pour tout $\\nu \\in \\mathbb{R}$ en utilisant les valeurs de la transformée de Fourier discrète $\\hat{S}_n(\\nu_j)$ pour $j = -\\frac{n}{2}, \\ldots, \\frac{n}{2} - 1$. Pour ce faire, il considère $\\alpha = \\frac{1}{T}$ et obtient pour tout $\\nu \\in \\mathbb{R}$ la formule d'interpolation de Shannon suivante :\n$$\n\\hat{f}(\\nu) = \\sum_{j=-\\frac{n}{2}}^{\\frac{n}{2}-1} \\hat{S}_n\\left(\\frac{j}{T}\\right)\\, \\text{sinc}\\left(\\pi T\\left(\\nu - \\frac{j}{T}\\right)\\right)\n$$\n\nLe programme ci-dessous illustre l'utilisation du théorème d'interpolation de Shannon pour calculer la transformée de Fourier d'une fonction $f$ en un point $\\nu$.\n\n::: {#f4c53fdf .cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\n\ndef shannon(tf, nu, T):\n    \"\"\"\n    Approxime la valeur de la transformée de Fourier de la fonction f en la fréquence 'nu'\n    à partir de ses valeurs discrètes calculées via la FFT.\n\n    Paramètres :\n    - tf : tableau numpy, valeurs de la TF (centrées avec fftshift) aux fréquences j/T pour j = -n/2, ..., n/2 - 1\n    - nu : float, fréquence à laquelle on veut approximer la TF\n    - T  : float, largeur de la fenêtre temporelle utilisée pour la FFT\n\n    Retour :\n    - tfnu : approximation de la TF en la fréquence 'nu'\n    \"\"\"\n    n = len(tf)\n    tfnu = 0.0\n    for j in range(n):\n        k = j - n // 2  # correspond à l'indice j dans {-n/2, ..., n/2 - 1}\n        tfnu += tf[j] * np.sinc(T * nu - k)  # np.sinc(x) = sin(pi x)/(pi x) en numpy\n\n    return tfnu\n```\n:::\n\n\nEnfin, nous pouvons definir la \n\n::: {#a6de46db .cell execution_count=10}\n``` {.python .cell-code}\ndef fourier_at_nu(f, T, n, nu):\n    \"\"\"\n    Calcule la transformée de Fourier de f en la fréquence nu\n    en utilisant tffft + interpolation de Shannon.\n    \"\"\"\n    tf, _, _ = tffft(f, T, n)\n    return shannon(tf, nu, T)\n```\n:::\n\n\n::: {#d023faa4 .cell execution_count=11}\n``` {.python .cell-code}\na = 0.5\nf = lambda t: np.exp(-a * np.abs(t))                          # Fonction à transformer\nfhat_exact = lambda nu: (2 * a) / (a**2 + 4 * np.pi**2 * nu**2)  # TF exacte\n\nT = 40     # largeur de la fenêtre\nn = 2**10  # nombre de points de discrétisation\n\n# Calcul pour nu = 3/T\nnu = 3 / T\n# Valeur exacte de la TF\nexact_value = fhat_exact(nu)\n# Approximation de la TF en nu\napprox_value = fourier_at_nu(f, T, n, nu)\nprint(f\"Exact value at nu={nu}: {exact_value}\")\nprint(f\"Approximation at nu={nu}: {approx_value}\")\n\n# Calcul pour nu = pi/T\nnu = np.pi / T\n# Valeur exacte de la TF\nexact_value = fhat_exact(nu)\n# Approximation de la TF en nu\napprox_value = fourier_at_nu(f, T, n, nu)\nprint(f\"Exact value at nu={nu}: {exact_value}\")\nprint(f\"Approximation at nu={nu}: {approx_value}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExact value at nu=0.075: 2.118347413776218\nApproximation at nu=0.075: (2.1185707502943534-3.313537429625715e-17j)\nExact value at nu=0.07853981633974483: 2.0262491352594427\nApproximation at nu=0.07853981633974483: (2.0264201680784835-2.0283412100428305e-17j)\n```\n:::\n:::\n\n\nUne alternative à l'interpolation de Shannon est d'utiliser d'autres méthodes d'interpolation comme l'interpolation de Lagrange ou l'interpolation de Newton. \n\n## Conclusion\n\n",
    "supporting": [
      "fourrier_transformation_files"
    ],
    "filters": [],
    "includes": {}
  }
}