{
  "hash": "338dada6f4f0a5b360d78cee45871510",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Fourrier Transformation\"\nsubtitle: \"\"\ndate: last-modified\nsidebar: auto\nnumber-sections: false\ntoc: true\nauthor:\n  - Jumbong Junior \n\ncategories: []\ntags: [\"\"]\ntitle-block-banner: false\nbibliography: references.bib\nformat: \n  html: \n    mainfont: Times New Roman\n    fontsize: 1.1em\n\njupyter: python3\nnotice: |\n    @balac2011transformee @cooley1965algorithm\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Introduction\n\nThe primary goal of the Fourier transformation is to analyze signals by decomposing them into their constituent frequencies. It was Joseph Fourier who first recognized the significance of spectral decomposition of a signal. Indeed, he demonstrated that any periodic signal can be decomposed into a finite sum of sinusoidal signals with constant frequencies and amplitudes. The finite set of these frequencies constitutes the spectrum of the signal. \n\nBeyond spectral analysis, the Fourier transformation is employed in solving partial differential equations, evaluating integrals, and computing sums of series. It has applications in various fields, including physics, engineering, and signal processing. In recent years, it has found new uses in finance, such as estimating financial asset volatility, which We will cover in future posts.\n\nIn this article, we explore the numerical computation of the Fourier transform for both real and complex functions. Drawing on the work of @balac2011transformee, who proposed a quadrature-based approach, we illustrate how this method can be applied. We also demonstrate how the Fast Fourier Transform (FFT) algorithm [ for more details see @cooley1965algorithm] enables efficient computation of the discrete Fourier transform, making it well-suited for calculating the Fourier transform of integrable functions and the Fourier coefficients of periodic functions.\n\nThis article was motivated by the realization that the numerical methods implemented in Python—such as [`scipy.fft` and `numpy.fft`] do not directly compute the Fourier transform of a function. This observation had already been made by @balac2011transformee in the context of MATLAB.\n\n::: {#014e76e4 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, fftshift\n\n# Define the function f(t) = exp(-pi * t^2)\ndef f(t):\n    return np.exp(-np.pi * t**2)\n\n# Parameters\nN = 1024\nT = 1.0 / 64\nt = np.linspace(-N/2*T, N/2*T, N, endpoint=False)\ny = f(t)\n\n# FFT with scipy\nyf_scipy = fftshift(fft(y)) * T\nxf = fftshift(fftfreq(N, T))\nFT_exact = np.exp(-np.pi * xf**2)\n\n# FFT with numpy\nyf_numpy = np.fft.fftshift(np.fft.fft(y)) * T\nxf_numpy = np.fft.fftshift(np.fft.fftfreq(N, T))\n\n# Plot with subplot_mosaic\nfig, axs = plt.subplot_mosaic([[\"scipy\", \"numpy\"]], figsize=(14, 5), layout=\"constrained\", sharey=True)\n\n# Scipy FFT\naxs[\"scipy\"].plot(xf, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[\"scipy\"].plot(xf, np.real(yf_scipy), 'r--', linewidth=1, label='FFT (scipy)')\naxs[\"scipy\"].set_xlim(-6, 6)\naxs[\"scipy\"].set_ylim(-1, 1)\naxs[\"scipy\"].set_title(\"Scipy FFT\")\naxs[\"scipy\"].set_xlabel(\"Frequency\")\naxs[\"scipy\"].set_ylabel(\"Amplitude\")\naxs[\"scipy\"].legend()\naxs[\"scipy\"].grid(False)\n\n# NumPy FFT\naxs[\"numpy\"].plot(xf_numpy, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[\"numpy\"].plot(xf_numpy, np.real(yf_numpy), 'b--', linewidth=1, label='FFT (numpy)')\naxs[\"numpy\"].set_xlim(-6, 6)\naxs[\"numpy\"].set_title(\"NumPy FFT\")\naxs[\"numpy\"].set_xlabel(\"Frequency\")\naxs[\"numpy\"].legend()\naxs[\"numpy\"].grid(False)\n\nplt.suptitle(\"Comparison of FFT Implementations vs. Exact Fourier Transform\", fontsize=14)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-2-output-1.png){width=1355 height=491}\n:::\n:::\n\n\n## Definition and Properties of the Fourier Transform\n\nWe must first define the space in which the function we want to compute the Fourier transform is defined and the caracteristics they must satisfy so that the Fourier transform exists.\nThese functions are defined in the space of integrable functions, denoted by $L^1(\\mathbb{R,K})$ which are functions $f:\\mathbb{R} \\to \\mathbb{K}$ [where $\\mathbb{K}$ is either $\\mathbb{R}$ or $\\mathbb{C}$]. These functions are integrable in the sense of Lebesgue, meaning that the integral of their absolute value is finite:\n$$\n\\int_{-\\infty}^{+\\infty} |f(t)| dt < +\\infty.\n$$\n\nSo for a function $f$ to be in $L^1(\\mathbb{R,K})$, the product $f(t) \\cdot e^{-2i\\pi\\nu t}$ is integrable for all $\\nu \\in \\mathbb{R}$. And for all $\\nu \\in \\mathbb{R}$, the function $\\hat{f}$ [notée egalement $F(f)$] defined by \n$$\n\\hat{f}(\\nu) = \\int_{-\\infty}^{+\\infty}\nf(x) e^{-2i\\pi\\nu t} dt\n$$\n\nis well-defined and is called the Fourier transform of $f$. \n\nWe deduce in this formula that a Fourier transform is a complex-valued function, and it is a linear operator. We can also deduce others properties of the Fourier transform in particular for a function $f$ in $L^1(\\mathbb{R,R})$, une fonction à valeurs réelles :\n\n- Translation property: If $f$ is in $L^1(\\mathbb{R,K})$, $t_0 \\in \\mathbb{R}$,  and $h : t \\in \\mathbb{R} \\mapsto f(t - t_0)$, we have $h \\in L^1(\\mathbb{R,K})$ and $\\hat{h}(\\nu) = e^{-2i\\pi\\nu t_0} \\hat{f}(\\nu)$.\n- Homothety property: If $f$ is in $L^1(\\mathbb{R,K})$ and $a \\in \\mathbb{R}$, then the function $g : t \\in \\mathbb{R} \\mapsto f(at)$ is in $L^1(\\mathbb{R,K})$ and $\\hat{g}(\\nu) = \\frac{1}{|a|} \\hat{f}\\left(\\frac{\\nu}{a}\\right)$.\n\n- Modulation property: If $f$ is in $L^1(\\mathbb{R,K})$ and $\\nu_0 \\in \\mathbb{R}$,  and $h : t \\in \\mathbb{R} \\mapsto f(t) e^{2i\\pi\\nu_0 t}$, we have $h \\in L^1(\\mathbb{R,K})$ and $\\hat{h}(\\nu) = \\hat{f}(\\nu - \\nu_0)$.\n\n- If $f \\in L^1(\\mathbb{R,R})$ and est pair, then $\\hat{f}$ is also real-valued and the real part of $\\hat{f}$ is also an even function.\n- If $f$ is in $L^1(\\mathbb{R,R})$ and is odd, then $\\hat{f}$ is est une fonction imaginaire pure and the imaginary part of $\\hat{f}$ is also an odd function.\n\nFor some functions, the Fourier transform can be computed analytically. For example, for the function $f : t \\in \\mathbb{R} \\mapsto \\mathbb{1}_{[-\\frac{a}{2}, \\frac{a}{2}]}(t)$, the Fourier transform is given by:\n$$\n\\hat{f} : \\nu \\in \\mathbb{R} \\mapsto a sinc(a \\pi \\nu)\n$$\nwhere $sinc(t) = \\frac{\\sin(t)}{t}$ is the sinc function.\n\nHowever, for many functions, the Fourier transform cannot be computed analytically. In such cases, we can use numerical methods to approximate the Fourier transform. We will explore these numerical dans la suite of this article.\n\n## How to approximate the Fourier Transform?\n\nThe Fourier transform of a function $f$ is defined as an integral over the entire real line. However, for the functions that are integral in the sense of lebesgue and that have a practical applications tend to 0 as $|t| \\to +\\infty$. And we can approximate the Fourier transform by integrating over a finite interval $[-T, T]$. If the lenght of the interval is large enough, or if the function decays quickly when t tends to infinity, this approximation will be accurate.\n\n$$\n\\hat{f}(\\nu) \\approx \\int_{-T}^{T} f(t) e^{-2i\\pi\\nu t} dt\n$$\n\nIn his article, @balac2011transformee va plus loin en montrant qu'approximating the Fourier transform met en oeuvre trois outils mathématiques :\n\n- Les séries de Fourier dans le cadre d'un signal périodique.\n- La transformée de Fourier dans le cadre d'un signal non périodique.\n- La transformée de Fourier discrète dans le cadre d'un signal discret.\n\nAnd for each of these tools, computing the Fourier transform revient à calculer l'intgrale below:\n$$\n\\hat{f}(\\nu) \\approx \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t) e^{-2i\\pi\\nu t} dt\n$$\nI recommends reading his article for more details on these three tools. Then we will focus on the numerical computation of the Fourier transform using quadrature methods, which is a numerical integration technique.\n\n## Numerical Computation of the Fourier Transform\n\nWe show that to compute the Fourier transform of a function $f$ consists to approximating it by the integral below in the interval $[-\\frac{T}{2}, \\frac{T}{2}]$:\n$$\n\\underbrace{\n  \\int_{-\\infty}^{+\\infty} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\hat{f}(\\nu)}\n\\approx\n\\underbrace{\n  \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\tilde{S}(\\nu)}\n$$\n\nwhere T is a large enough number such that the integral converges. Une valeur approchée of the integral $\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt$ can be computed using quadrature methods. In the next section, we will approximate the integral using the quadrature method of rectangles à gauche.\n\n## Quadrature Method of Rectangles à Gauche\n\nFor computing the integral $\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt$, using the quadrature method of rectangles à gauche, we must respect the following steps:\n1. **Discretization of the Interval**: We discretize the interval $[-\\frac{T}{2}, \\frac{T}{2}]$ into $N$ uniform subintervals of length $h_t = \\frac{T}{N}$. The points in the interval are given by:\n\n$$\nt_k = -\\frac{T}{2} + k \\cdot h_t, \\quad k = 0, 1, \\ldots, N-1.\n$$\n\n2. **Approximation of the Integral**: Using the Chasles relation, we can approximate the integral $\\tilde{S}(\\nu)$ as follows:\n\n$$\n\\tilde{S}(\\nu) = \\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt = \\sum_{k=0}^{N-1}  \\int_{t_k}^{t_{k+1}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt.\n$$\n\nBy taking into account that we have $t_{k+1} - t_k = h_t$, and $t_k = -\\frac{T}{2} + k \\cdot h_t = T(\\frac{k}{N} - \\frac{1}{2})$, we can rewrite the integral as:\n$$\n\\tilde{S}(\\nu) = \\sum_{k=0}^{N-1} f(t_k) e^{-2\\pi i \\nu t_k} h_t.\n$$\n3. **Final Formula**: The final formula for the approximation of the Fourier transform is given by:\n\n$$\n\\boxed{\n\\forall \\nu \\in \\mathbb{R} \\quad\n\\underbrace{\n\\int_{-\\frac{T}{2}}^{\\frac{T}{2}} f(t)\\, e^{-2\\pi i \\nu t} \\, dt\n}_{=\\,\\tilde{S}(\\nu)}\n\\approx\n\\underbrace{\n\\frac{T}{n} e^{i \\pi \\nu T} \\sum_{k=0}^{n-1} f_k\\, e^{-2 i \\pi \\nu T k / n}\n}_{=\\,\\tilde{S}_n(\\nu)}\n\\quad \\text{où } f_k = f\\left( \\frac{2k - n}{2n} T \\right).\n}\n$$\n\n### Mis en Oeuvre in Python \n\nThe function `tfquad` below implements the quadrature method of rectangles à gauche to compute the Fourier transform of a function `f` at a given frequency `nu`. \n\n::: {#08418428 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\ndef tfquad(f, nu, n, T):\n    \"\"\"\n    Computes the Fourier transform of a function f at frequency nu\n    using left Riemann sum quadrature over the interval [-T/2, T/2].\n\n    Parameters:\n    ----------\n    f : callable\n        The function to transform. Must accept a NumPy array as input.\n    nu : float\n        The frequency at which to evaluate the Fourier transform.\n    n : int\n        Number of quadrature points.\n    T : float\n        Width of the time window [-T/2, T/2].\n\n    Returns:\n    -------\n    tfnu : complex\n        Approximated value of the Fourier transform at frequency nu.\n    \"\"\"\n    k = np.arange(n)\n    t_k = (k / n - 0.5) * T\n    weights = np.exp(-2j * np.pi * nu * T * k / n)\n    prefactor = (T / n) * np.exp(1j * np.pi * nu * T)\n\n    return prefactor * np.sum(f(t_k) * weights)\n```\n:::\n\n\nWe can also use the function scipy's `quad` functionnfor defining the Fourier transform of a function `f` at a given frequency `nu`.  The function `tf_integral` below implements this approach. It uses numerical integration to compute the Fourier transform of a function `f` over the interval $[-T/2, T/2]$.\n\n::: {#875353cc .cell execution_count=3}\n``` {.python .cell-code}\nfrom scipy.integrate import quad\n\ndef tf_integral(f, nu, T):\n    \"\"\"Compute FT of f at frequency nu over [-T/2, T/2] using scipy quad.\"\"\"\n    real_part = quad(lambda t: np.real(f(t) * np.exp(-2j * np.pi * nu * t)), -T/2, T/2)[0]\n    imag_part = quad(lambda t: np.imag(f(t) * np.exp(-2j * np.pi * nu * t)), -T/2, T/2)[0]\n    return real_part + 1j * imag_part\n```\n:::\n\n\n::: {#da4ca08f .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ----- Function Definitions -----\n\ndef f(t):\n    \"\"\"Indicator function on [-1, 1].\"\"\"\n    return np.where(np.abs(t) <= 1, 1.0, 0.0)\n\ndef exact_fourier_transform(nu):\n    \"\"\"Analytical FT of the indicator function over [-1, 1].\"\"\"\n    # f̂(ν) = ∫_{-1}^{1} e^{-2πiνt} dt = 2 * sinc(2ν)\n    return 2 * np.sinc(2 * nu)\n\n\n# ----- Computation -----\n\nT = 2.0\nn = 32\nnu_vals = np.linspace(-6, 6, 500)\nexact_vals = exact_fourier_transform(nu_vals)\napprox_vals = np.array([tfquad(f, nu, n, T) for nu in nu_vals])\n```\n:::\n\n\n::: {#643c35d1 .cell execution_count=5}\n``` {.python .cell-code}\nfig, axs = plt.subplot_mosaic([[\"quad\", \"tfquad\"]], figsize=(12, 4), layout=\"constrained\")\n\n# Plot using scipy.integrate.quad\naxs[\"quad\"].plot(nu_vals, np.real(exact_vals), 'b-', linewidth=2, label=r'$\\hat{f}$ (quad)')\naxs[\"quad\"].plot(nu_vals, np.real(approx_vals), 'r--', linewidth=1.5, label=r'approximation $\\hat{S}_n$')\naxs[\"quad\"].set_title(\"TF avec scipy.integrate.quad\")\naxs[\"quad\"].set_xlabel(r'$\\nu$')\naxs[\"quad\"].set_ylabel('Amplitude')\naxs[\"quad\"].grid(False)\naxs[\"quad\"].legend()\naxs[\"quad\"].set_ylim(-0.5, 2.1)\n\n# Plot using tfquad implementation\naxs[\"tfquad\"].plot(nu_vals, np.real(exact_vals), 'b-', linewidth=2, label=r'$\\hat{f}$ (exact)')\naxs[\"tfquad\"].plot(nu_vals, np.real(approx_vals), 'r--', linewidth=1.5, label=r'approximation $\\hat{S}_n$')\naxs[\"tfquad\"].set_title(\"TF avec tfquad (rectangles)\")\naxs[\"tfquad\"].set_xlabel(r'$\\nu$')\naxs[\"tfquad\"].grid(False)\naxs[\"tfquad\"].legend()\naxs[\"tfquad\"].set_ylim(-0.5, 2.1)\n\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-6-output-1.png){width=1163 height=395}\n:::\n:::\n\n\n",
    "supporting": [
      "fourrier_transformation_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}