{
  "hash": "abfc4123299a05645c796072e9095b78",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Fourrier Transformation\"\nsubtitle: \"\"\ndate: last-modified\nsidebar: auto\nnumber-sections: false\ntoc: true\nauthor:\n  - Jumbong Junior \n\ncategories: []\ntags: [\"\"]\ntitle-block-banner: false\nbibliography: references.bib\nformat: \n  html: \n    mainfont: Times New Roman\n    fontsize: 1.1em\n\njupyter: python3\nnotice: |\n    @balac2011transformee @cooley1965algorithm\n---\n\n\n\n\n# Introduction\n\nThe primary goal of the Fourier transformation is to analyze signals by decomposing them into their constituent frequencies. It was Joseph Fourier who first recognized the significance of spectral decomposition of a signal. Indeed, he demonstrated that any periodic signal can be decomposed into a finite sum of sinusoidal signals with constant frequencies and amplitudes. The finite set of these frequencies constitutes the spectrum of the signal. \n\nBeyond spectral analysis, the Fourier transformation is employed in solving partial differential equations, evaluating integrals, and computing sums of series. It has applications in various fields, including physics, engineering, and signal processing. In recent years, it has found new uses in finance, such as estimating financial asset volatility, which We will cover in future posts.\n\nIn this article, we explore the numerical computation of the Fourier transform for both real and complex functions. Drawing on the work of @balac2011transformee, who proposed a quadrature-based approach, we illustrate how this method can be applied. We also demonstrate how the Fast Fourier Transform (FFT) algorithm [ for more details see @cooley1965algorithm] enables efficient computation of the discrete Fourier transform, making it well-suited for calculating the Fourier transform of integrable functions and the Fourier coefficients of periodic functions.\n\nThis article was motivated by the realization that the numerical methods implemented in Pythonâ€”such as [`scipy.fft` and `numpy.fft`] do not directly compute the Fourier transform of a function. This observation had already been made by @balac2011transformee in the context of MATLAB.\n\n::: {#583e6f3f .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.fft import fft, fftfreq, fftshift\n\n# Define the function f(t) = exp(-pi * t^2)\ndef f(t):\n    return np.exp(-np.pi * t**2)\n\n# Parameters\nN = 1024\nT = 1.0 / 64\nt = np.linspace(-N/2*T, N/2*T, N, endpoint=False)\ny = f(t)\n\n# FFT with scipy\nyf_scipy = fftshift(fft(y)) * T\nxf = fftshift(fftfreq(N, T))\nFT_exact = np.exp(-np.pi * xf**2)\n\n# FFT with numpy\nyf_numpy = np.fft.fftshift(np.fft.fft(y)) * T\nxf_numpy = np.fft.fftshift(np.fft.fftfreq(N, T))\n\n# Plot side-by-side\nfig, axs = plt.subplots(1, 2, figsize=(14, 5), sharey=True)\n\n# Left: Scipy FFT\naxs[0].plot(xf, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[0].plot(xf, np.real(yf_scipy), 'r--', linewidth=1, label='FFT (scipy)')\naxs[0].set_xlim(-6, 6)\naxs[0].set_ylim(-1, 1)\naxs[0].set_title(\"Scipy FFT\")\naxs[0].set_xlabel(\"Frequency\")\naxs[0].set_ylabel(\"Amplitude\")\naxs[0].legend()\naxs[0].grid(True)\n\n# Right: Numpy FFT\naxs[1].plot(xf_numpy, FT_exact, 'k-', linewidth=1.5, label='Exact FT')\naxs[1].plot(xf_numpy, np.real(yf_numpy), 'b--', linewidth=1, label='FFT (numpy)')\naxs[1].set_xlim(-6, 6)\naxs[1].set_title(\"NumPy FFT\")\naxs[1].set_xlabel(\"Frequency\")\naxs[1].legend()\naxs[1].grid(True)\n\nplt.suptitle(\"Comparison of FFT Implementations vs. Exact Fourier Transform\", fontsize=14)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](fourrier_transformation_files/figure-html/cell-2-output-1.png){width=1334 height=475}\n:::\n:::\n\n\n",
    "supporting": [
      "fourrier_transformation_files"
    ],
    "filters": [],
    "includes": {}
  }
}