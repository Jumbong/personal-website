<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jumbong Junior">
<meta name="dcterms.date" content="2025-10-26">

<title>Fourrier Transformation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../flavicon.jpeg" rel="icon" type="image/jpeg">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index_gdr.html"> 
<span class="menu-text">Daily Story</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Summary</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#definition-and-properties-of-the-fourier-transform" id="toc-definition-and-properties-of-the-fourier-transform" class="nav-link" data-scroll-target="#definition-and-properties-of-the-fourier-transform">Definition and Properties of the Fourier Transform</a></li>
  <li><a href="#how-to-approximate-the-fourier-transform" id="toc-how-to-approximate-the-fourier-transform" class="nav-link" data-scroll-target="#how-to-approximate-the-fourier-transform">How to approximate the Fourier Transform?</a></li>
  <li><a href="#numerical-computation-of-the-fourier-transform" id="toc-numerical-computation-of-the-fourier-transform" class="nav-link" data-scroll-target="#numerical-computation-of-the-fourier-transform">Numerical Computation of the Fourier Transform</a></li>
  <li><a href="#quadrature-method-of-left-rectangles" id="toc-quadrature-method-of-left-rectangles" class="nav-link" data-scroll-target="#quadrature-method-of-left-rectangles">Quadrature method of left Rectangles</a>
  <ul class="collapse">
  <li><a href="#implementation-of-the-left-rectangle-quadrature-method-in-python." id="toc-implementation-of-the-left-rectangle-quadrature-method-in-python." class="nav-link" data-scroll-target="#implementation-of-the-left-rectangle-quadrature-method-in-python.">Implementation of the left rectangle quadrature method in Python.</a></li>
  </ul></li>
  <li><a href="#characterizing-the-approximation-using-the-left-rectangle-quadrature-method" id="toc-characterizing-the-approximation-using-the-left-rectangle-quadrature-method" class="nav-link" data-scroll-target="#characterizing-the-approximation-using-the-left-rectangle-quadrature-method">Characterizing the approximation using the left rectangle quadrature method</a>
  <ul class="collapse">
  <li><a href="#the-approximation-of-the-fourier-transform-hatf-using-the-left-rectangle-quadrature-method-exhibits-an-oscillatory-behavior-by-nature." id="toc-the-approximation-of-the-fourier-transform-hatf-using-the-left-rectangle-quadrature-method-exhibits-an-oscillatory-behavior-by-nature." class="nav-link" data-scroll-target="#the-approximation-of-the-fourier-transform-hatf-using-the-left-rectangle-quadrature-method-exhibits-an-oscillatory-behavior-by-nature.">The approximation of the Fourier transform <span class="math inline">\(\hat{f}\)</span> using the <strong>left rectangle quadrature method</strong> exhibits an <strong>oscillatory behavior</strong> by nature.</a></li>
  </ul></li>
  <li><a href="#the-approximation-obtained-using-the-left-rectangle-quadrature-method-is-periodic-in-nature." id="toc-the-approximation-obtained-using-the-left-rectangle-quadrature-method-is-periodic-in-nature." class="nav-link" data-scroll-target="#the-approximation-obtained-using-the-left-rectangle-quadrature-method-is-periodic-in-nature.">The approximation obtained using the left rectangle quadrature method is periodic in nature.</a></li>
  <li><a href="#computing-the-fourier-transform-at-frequency-nu-using-the-fft-algorithm." id="toc-computing-the-fourier-transform-at-frequency-nu-using-the-fft-algorithm." class="nav-link" data-scroll-target="#computing-the-fourier-transform-at-frequency-nu-using-the-fft-algorithm.">Computing the Fourier Transform at Frequency <span class="math inline">\(\nu\)</span> Using the FFT Algorithm.</a></li>
  <li><a href="#using-shannons-interpolation-theorem-to-compute-the-fourier-transform-of-a-function-f-at-a-point-nu" id="toc-using-shannons-interpolation-theorem-to-compute-the-fourier-transform-of-a-function-f-at-a-point-nu" class="nav-link" data-scroll-target="#using-shannons-interpolation-theorem-to-compute-the-fourier-transform-of-a-function-f-at-a-point-nu">Using Shannon’s Interpolation Theorem to Compute the Fourier Transform of a Function <span class="math inline">\(f\)</span> at a Point <span class="math inline">\(\nu\)</span></a></li>
  </ul></li>
  <li><a href="#computing-the-fourier-transform-at-frequency-ν-using-the-fft-algorithm-in-numpy-and-scipy" id="toc-computing-the-fourier-transform-at-frequency-ν-using-the-fft-algorithm-in-numpy-and-scipy" class="nav-link" data-scroll-target="#computing-the-fourier-transform-at-frequency-ν-using-the-fft-algorithm-in-numpy-and-scipy">Computing the Fourier Transform at Frequency ν Using the FFT Algorithm in numpy and SciPy</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Fourrier Transformation</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jumbong Junior </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 26, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>When we were in our third year of the Risk Management program at an engineering school, we took a course on the calibration of stochastic processes. To assess our understanding, the instructor gave us a selection of academic papers and asked us to choose one, study it thoroughly, and reproduce its results.</p>
<p>We chose the paper by <span class="citation" data-cites="el2013parametric">El Kolei (<a href="#ref-el2013parametric" role="doc-biblioref">2013</a>)</span>, which proposes a method for estimating the parameters of stochastic volatility models based on contrast minimization and deconvolution.</p>
<p>To do so, we had to implement an optimization algorithm that relies on the Fourier transform to evaluate the following function:</p>
<p><span class="math display">\[
\hat{f}(\nu) = \int_{-\infty}^{+\infty} f_{\theta}(t) e^{-2i\pi\nu t} dt, \quad\text{for all } \nu \in \mathbb{R}
\]</span> Where <span class="math inline">\(f_{\theta}(y) = \frac{1}{2\sqrt{\pi}} \left(\frac{-i \phi y \gamma^2 \exp\left(-\frac{y^2}{2} \gamma^2\right)}{\exp\left(-i \mathcal{E} y\right) 2^{iy} \Gamma\left(\frac{1}{2} + iy\right)}\right)\)</span> and <span class="math inline">\(\theta = (\phi, \gamma, \mathcal{E})\)</span> is the vector of parameters to be estimated.</p>
<p>To compute the Fourier transform of <span class="math inline">\(f\)</span>, <span class="citation" data-cites="el2013parametric">El Kolei (<a href="#ref-el2013parametric" role="doc-biblioref">2013</a>)</span> uses the left Riemann sum (rectangle quadrature) method implemented in MATLAB and suggests that using the Fast Fourier Transform (FFT) algorithm could accelerate the computation of the Fourier transform.</p>
<p>We decided to reproduce the paper using Python. Implementing the left rectangle quadrature method was straightforward, and we initially believed that the <code>scipy.fft</code> and <code>numpy.fft</code> libraries would allow us to compute the Fourier transform of <span class="math inline">\(f\)</span> using the FFT algorithm.</p>
<p>However, we were surprised to discover that these functions do not compute the Fourier transform of a continuous function but rather the discrete Fourier transform (DFT) of a finite sequence. The plot below illustrates this observation.</p>
<div id="6b8a0266" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft, fftfreq, fftshift</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function f(t) = exp(-pi * t^2)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="dv">64</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span>N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(t)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># FFT with scipy</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>yf_scipy <span class="op">=</span> fftshift(fft(y)) <span class="op">*</span> T</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>xf <span class="op">=</span> fftshift(fftfreq(N, T))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>FT_exact <span class="op">=</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> xf<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># FFT with numpy</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>yf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fft(y)) <span class="op">*</span> T</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>xf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fftfreq(N, T))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot with subplot_mosaic</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplot_mosaic([[<span class="st">"scipy"</span>, <span class="st">"numpy"</span>]], figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>), layout<span class="op">=</span><span class="st">"constrained"</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Scipy FFT</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].plot(xf, FT_exact, <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Exact FT'</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].plot(xf, np.real(yf_scipy), <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'FFT (scipy)'</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_ylim(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_title(<span class="st">"Scipy FFT"</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_xlabel(<span class="st">"Frequency"</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].legend()</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].grid(<span class="va">False</span>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co"># NumPy FFT</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].plot(xf_numpy, FT_exact, <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Exact FT'</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].plot(xf_numpy, np.real(yf_numpy), <span class="st">'b--'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'FFT (numpy)'</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_title(<span class="st">"NumPy FFT"</span>)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_xlabel(<span class="st">"Frequency"</span>)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].legend()</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].grid(<span class="va">False</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of FFT Implementations vs. Exact Fourier Transform"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-2-output-1.png" width="683" height="491" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>This motivation led us to write this article to explain how to compute the Fourier transform of a function using both the left Riemann sum (rectangle quadrature) method and the Fast Fourier Transform (FFT) algorithm.</p>
<p>The paper by <span class="citation" data-cites="el2013parametric">El Kolei (<a href="#ref-el2013parametric" role="doc-biblioref">2013</a>)</span> illustrates an application of the Fourier transform in finance and ecology. Beyond these domains, the Fourier transform plays a key role in spectral analysis, solving partial differential equations, evaluating integrals, and computing series sums. It is widely used in physics, engineering, and signal processing.</p>
<p>In the literature, several articles discuss approximating the Fourier transform and implementing it using numerical methods. However, we have not found a source as clear and comprehensive as the one by <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span>, which proposes a quadrature-based approach to compute the Fourier transform and explains how to use the FFT algorithm to compute the discrete Fourier transform.</p>
<p>We use <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> as our primary reference to show how to approximate the Fourier transform in Python using both methods: the left rectangle quadrature method and the Fast Fourier Transform (FFT) algorithm.</p>
<section id="definition-and-properties-of-the-fourier-transform" class="level2">
<h2 class="anchored" data-anchor-id="definition-and-properties-of-the-fourier-transform">Definition and Properties of the Fourier Transform</h2>
<p>We adopt the framework presented by <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> to define the Fourier transform of a function <span class="math inline">\(f\)</span> and to introduce its properties.</p>
<p>The functions considered belong to the space of integrable functions, denoted <span class="math inline">\(L^1(\mathbb{R,K})\)</span>, consisting of all functions <span class="math inline">\(f:\mathbb{R} \to \mathbb{K}\)</span> [where <span class="math inline">\(\mathbb{K}\)</span> is either <span class="math inline">\(\mathbb{R}\)</span> or <span class="math inline">\(\mathbb{C}\)</span>]. These functions are integrable in the sense of Lebesgue, meaning that the integral of their absolute value is finite: <span class="math display">\[
\int_{-\infty}^{+\infty} |f(t)| dt &lt; +\infty.
\]</span></p>
<p>So, for a function <span class="math inline">\(f\)</span> to belong to <span class="math inline">\(L^1(\mathbb{R}, \mathbb{K})\)</span>, the product <span class="math inline">\(f(t) \cdot e^{-2i\pi\nu t}\)</span> must also be integrable for all <span class="math inline">\(\nu \in \mathbb{R}\)</span>. In that case, the <strong>Fourier transform</strong> of <span class="math inline">\(f\)</span>, denoted <span class="math inline">\(\hat{f}\)</span> (or sometimes <span class="math inline">\(\mathcal{F}(f)\)</span>), is defined for all <span class="math inline">\(\nu \in \mathbb{R}\)</span> by:</p>
<p><span class="math display">\[
\hat{f}(\nu) = \int_{-\infty}^{+\infty}
f(t) \, e^{-2i\pi\nu t} \, dt.
\]</span></p>
<p>The key takeaway is that the Fourier transform <span class="math inline">\(\hat{f}\)</span> of a function <span class="math inline">\(f\)</span> is a complex-valued, linear function that depends on the frequency <span class="math inline">\(\nu\)</span>. If <span class="math inline">\(f \in L^1(\mathbb{R})\)</span>, is real-valued and even, then <span class="math inline">\(\hat{f}\)</span> is also real-valued and even. Conversely, if <span class="math inline">\(f\)</span> is real-valued and odd, then <span class="math inline">\(\hat{f}\)</span> is purely imaginary and odd as well.</p>
<p>For some functions, the Fourier transform can be computed analytically. For example, for the function <span class="math inline">\(f : t \in \mathbb{R} \mapsto \mathbb{1}_{[-\frac{a}{2}, \frac{a}{2}]}(t)\)</span>, the Fourier transform is given by: <span class="math display">\[
\hat{f} : \nu \in \mathbb{R} \mapsto a sinc(a \pi \nu)
\]</span> where <span class="math inline">\(sinc(t) = \frac{\sin(t)}{t}\)</span> is the sinc function.</p>
<p>However, for many functions, the Fourier transform cannot be computed analytically. In such cases, we can use numerical methods to approximate it. We will explore these numerical approaches in the following sections of this article.</p>
</section>
<section id="how-to-approximate-the-fourier-transform" class="level2">
<h2 class="anchored" data-anchor-id="how-to-approximate-the-fourier-transform">How to approximate the Fourier Transform?</h2>
<p>The Fourier transform of a function <span class="math inline">\(f\)</span> is defined as an integral over the entire real line. However, for the functions that are integral in the sense of lebesgue and that have a practical applications tend to 0 as <span class="math inline">\(|t| \to +\infty\)</span>. And we can approximate the Fourier transform by integrating over a finite interval <span class="math inline">\([-T, T]\)</span>. If the lenght of the interval is large enough, or if the function decays quickly when t tends to infinity, this approximation will be accurate.</p>
<p><span class="math display">\[
\hat{f}(\nu) \approx \int_{-T}^{T} f(t) e^{-2i\pi\nu t} dt
\]</span></p>
<p>In his article, <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> goes further by showing that approximating the Fourier transform involves three key mathematical tools:</p>
<ul>
<li><strong>Fourier series</strong>, in the context of a periodic signal,</li>
<li><strong>The Fourier transform</strong>, for non-periodic signals,</li>
<li><strong>The discrete Fourier transform</strong>, for discrete signals.</li>
</ul>
<p>For each of these tools, computing the Fourier transform essentially comes down to evaluating the following integral: <span class="math display">\[
\hat{f}(\nu) \approx \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-2i\pi\nu t} dt
\]</span> I recommend reading his article for more details on these three tools. Next, we will focus on the numerical computation of the Fourier transform using quadrature methods, a technique for performing numerical integration.</p>
</section>
<section id="numerical-computation-of-the-fourier-transform" class="level2">
<h2 class="anchored" data-anchor-id="numerical-computation-of-the-fourier-transform">Numerical Computation of the Fourier Transform</h2>
<p>We show that computing the Fourier transform of a function <span class="math inline">\(f\)</span> consists to approximating it by the integral the following integral over the interval <span class="math inline">\([-\frac{T}{2}, \frac{T}{2}]\)</span>: <span class="math display">\[
\boxed{
\underbrace{
  \int_{-\infty}^{+\infty} f(t)\, e^{-2\pi i \nu t} \, dt
}_{=\,\hat{f}(\nu)}
\approx
\underbrace{
  \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)\, e^{-2\pi i \nu t} \, dt
}_{=\,\tilde{S}(\nu)}
}
\]</span></p>
<p>where T is a large enough number such that the integral converges. Une valeur approchée of the integral <span class="math inline">\(\tilde{S}(\nu) = \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)\, e^{-2\pi i \nu t} \, dt\)</span> can be computed using quadrature methods. In the next section, we will approximate the integral using the quadrature method of rectangles à gauche.</p>
</section>
<section id="quadrature-method-of-left-rectangles" class="level2">
<h2 class="anchored" data-anchor-id="quadrature-method-of-left-rectangles">Quadrature method of left Rectangles</h2>
<p>To compute the integral <span class="math inline">\(\tilde{S}(\nu) = \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)\, e^{-2\pi i \nu t} \, dt\)</span>, using the quadrature method of left rectangles, we follow these steps:</p>
<ol type="1">
<li><strong>Discretization of the Interval:</strong>: We divide the interval <span class="math inline">\([-\frac{T}{2}, \frac{T}{2}]\)</span> into <span class="math inline">\(N\)</span> uniform subintervals of length <span class="math inline">\(h_t = \frac{T}{N}\)</span>. The discretization points[eft endpoints of the rectangles] in the interval are given by:</li>
</ol>
<p><span class="math display">\[
t_k = -\frac{T}{2} + k \cdot h_t, \quad k = 0, 1, \ldots, N-1.
\]</span></p>
<ol start="2" type="1">
<li><strong>Approximation of the Integral</strong>: Using the Chasles relation, we can approximate the integral <span class="math inline">\(\tilde{S}(\nu)\)</span> as follows:</li>
</ol>
<p><span class="math display">\[
\tilde{S}(\nu) = \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)\, e^{-2\pi i \nu t} \, dt = \sum_{k=0}^{N-1}  \int_{t_k}^{t_{k+1}} f(t)\, e^{-2\pi i \nu t} \, dt.
\]</span></p>
<p>By taking into account that we have <span class="math inline">\(t_{k+1} - t_k = h_t\)</span>, and <span class="math inline">\(t_k = -\frac{T}{2} + k \cdot h_t = T(\frac{k}{N} - \frac{1}{2})\)</span>, we can rewrite the integral as: <span class="math display">\[
\boxed{
\tilde{S}(\nu) = \sum_{k=0}^{N-1} f(t_k) e^{-2\pi i \nu t_k} h_t.
}
\]</span></p>
<p>We call it the <strong>quadrature method of left rectangles</strong> because it uses the <strong>left endpoint</strong> <span class="math inline">\(t_k\)</span> of each subinterval to approximate the value of the function <span class="math inline">\(f(t)\)</span> at that point.</p>
<ol start="3" type="1">
<li><strong>Final Formula</strong>: The final formula for the approximation of the Fourier transform is given by:</li>
</ol>
<p><span class="math display">\[
\boxed{
\forall \nu \in \mathbb{R} \quad
\underbrace{
\int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)\, e^{-2\pi i \nu t} \, dt
}_{=\,\tilde{S}(\nu)}
\approx
\underbrace{
\frac{T}{n} e^{i \pi \nu T} \sum_{k=0}^{n-1} f_k\, e^{-2 i \pi \nu T k / n}
}_{=\,\tilde{S}_n(\nu)}
\quad \text{où } f_k = f\left( \frac{2k - n}{2n} T \right).
}
\]</span></p>
<section id="implementation-of-the-left-rectangle-quadrature-method-in-python." class="level3">
<h3 class="anchored" data-anchor-id="implementation-of-the-left-rectangle-quadrature-method-in-python.">Implementation of the left rectangle quadrature method in Python.</h3>
<p>The function <code>tfquad</code> below implements the <strong>left rectangle quadrature method</strong> to compute the <strong>Fourier transform</strong> of a function <code>f</code> at a given frequency <code>nu</code>.</p>
<div id="f86d989b" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tfquad(f, nu, n, T):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Fourier transform of a function f at frequency nu</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    using left Riemann sum quadrature over the interval [-T/2, T/2].</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    f : callable</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">        The function to transform. Must accept a NumPy array as input.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    nu : float</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">        The frequency at which to evaluate the Fourier transform.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of quadrature points.</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    T : float</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Width of the time window [-T/2, T/2].</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">    tfnu : complex</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Approximated value of the Fourier transform at frequency nu.</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> np.arange(n)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    t_k <span class="op">=</span> (k <span class="op">/</span> n <span class="op">-</span> <span class="fl">0.5</span>) <span class="op">*</span> T</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> T <span class="op">*</span> k <span class="op">/</span> n)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    prefactor <span class="op">=</span> (T <span class="op">/</span> n) <span class="op">*</span> np.exp(<span class="ot">1j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> T)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prefactor <span class="op">*</span> np.<span class="bu">sum</span>(f(t_k) <span class="op">*</span> weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can also use SciPy’s <code>quad</code> function to define the <strong>Fourier transform</strong> of a function <code>f</code> at a given frequency <code>nu</code>. The function <code>tf_integral</code> below implements this approach. It uses numerical integration to compute the Fourier transform of <code>f</code> over the interval <span class="math inline">\([-T/2, T/2]\)</span>.</p>
<div id="4010aa34" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> quad</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tf_integral(f, nu, T):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute FT of f at frequency nu over [-T/2, T/2] using scipy quad."""</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    real_part <span class="op">=</span> quad(<span class="kw">lambda</span> t: np.real(f(t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> t)), <span class="op">-</span>T<span class="op">/</span><span class="dv">2</span>, T<span class="op">/</span><span class="dv">2</span>)[<span class="dv">0</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    imag_part <span class="op">=</span> quad(<span class="kw">lambda</span> t: np.imag(f(t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> t)), <span class="op">-</span>T<span class="op">/</span><span class="dv">2</span>, T<span class="op">/</span><span class="dv">2</span>)[<span class="dv">0</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> real_part <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> imag_part</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fbe04461" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ----- Function Definitions -----</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Indicator function on [-1, 1]."""</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(np.<span class="bu">abs</span>(t) <span class="op">&lt;=</span> <span class="dv">1</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exact_fourier_transform(nu):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Analytical FT of the indicator function over [-1, 1]."""</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># f̂(ν) = ∫_{-1}^{1} e^{-2πiνt} dt = 2 * sinc(2ν)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> np.sinc(<span class="dv">2</span> <span class="op">*</span> nu)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co"># ----- Computation -----</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>nu_vals <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">500</span>)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>exact_vals <span class="op">=</span> exact_fourier_transform(nu_vals)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>tfquad_vals <span class="op">=</span> np.array([tfquad(f, nu, n, T) <span class="cf">for</span> nu <span class="kw">in</span> nu_vals])</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the approximation using scipy integral</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>tf_integral_vals <span class="op">=</span> np.array([tf_integral(f, nu, T) <span class="cf">for</span> nu <span class="kw">in</span> nu_vals])</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co"># ----- Plotting -----</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplot_mosaic([[<span class="st">"tfquad"</span>, <span class="st">"quad"</span>]], figsize<span class="op">=</span>(<span class="fl">7.24</span>, <span class="fl">4.07</span>), dpi<span class="op">=</span><span class="dv">100</span>, layout<span class="op">=</span><span class="st">"constrained"</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot using tfquad implementation</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].plot(nu_vals, np.real(exact_vals), <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="vs">r'$\hat</span><span class="sc">{f}</span><span class="vs">$ (exact)'</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].plot(nu_vals, np.real(tfquad_vals), <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="vs">r'approximation $\hat</span><span class="sc">{S}</span><span class="vs">_n$'</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].set_title(<span class="st">"TF avec tfquad (rectangles)"</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].set_xlabel(<span class="vs">r'$\nu$'</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].grid(<span class="va">False</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"tfquad"</span>].set_ylim(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">2.1</span>)</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot using scipy.integrate.quad</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].plot(nu_vals, np.real(exact_vals), <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="vs">r'$\hat</span><span class="sc">{f}</span><span class="vs">$ (quad)'</span>)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].plot(nu_vals, np.real(tf_integral_vals), <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="vs">r'approximation $\hat</span><span class="sc">{S}</span><span class="vs">_n$'</span>)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].set_title(<span class="st">"TF avec scipy.integrate.quad"</span>)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].set_xlabel(<span class="vs">r'$\nu$'</span>)</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].set_ylabel(<span class="st">'Amplitude'</span>)</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].grid(<span class="va">False</span>)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"quad"</span>].set_ylim(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">2.1</span>)</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Global legend below the plots ---</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Take handles from one subplot only (assumes labels are consistent)</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>handles, labels <span class="op">=</span> axs[<span class="st">"quad"</span>].get_legend_handles_labels()</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>fig.legend(handles, labels,</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>           loc<span class="op">=</span><span class="st">'lower center'</span>, bbox_to_anchor<span class="op">=</span>(<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.05</span>),</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>           ncol<span class="op">=</span><span class="dv">3</span>, frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of FFT Implementations vs. Exact Fourier Transform"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-5-output-1.png" width="735" height="436" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We are now able to compute the Fourier transform of a function using the <strong>left rectangle quadrature method</strong>. Let’s take a closer look at the characteristics and limitations of this approximation.</p>
</section>
</section>
<section id="characterizing-the-approximation-using-the-left-rectangle-quadrature-method" class="level2">
<h2 class="anchored" data-anchor-id="characterizing-the-approximation-using-the-left-rectangle-quadrature-method">Characterizing the approximation using the left rectangle quadrature method</h2>
<section id="the-approximation-of-the-fourier-transform-hatf-using-the-left-rectangle-quadrature-method-exhibits-an-oscillatory-behavior-by-nature." class="level3">
<h3 class="anchored" data-anchor-id="the-approximation-of-the-fourier-transform-hatf-using-the-left-rectangle-quadrature-method-exhibits-an-oscillatory-behavior-by-nature.">The approximation of the Fourier transform <span class="math inline">\(\hat{f}\)</span> using the <strong>left rectangle quadrature method</strong> exhibits an <strong>oscillatory behavior</strong> by nature.</h3>
<p><span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> highlights that the Fourier transform <span class="math inline">\(\hat{f}\)</span> of the function <span class="math inline">\(f\)</span> is inherently <strong>oscillatory</strong>. This behavior arises from the <strong>complex exponential term</strong> <span class="math inline">\(e^{-2\pi i \nu t}\)</span> in the integral definition of the transform.</p>
<p>To illustrate this, the figure below shows the function</p>
<p><span class="math display">\[
f : t \in \mathbb{R} \mapsto e^{-t^2} \in \mathbb{R}
\]</span></p>
<p>along with the <strong>real and imaginary parts</strong> of its Fourier transform</p>
<p><span class="math display">\[
\hat{f} : \nu \in \mathbb{R} \mapsto \hat{f}(\nu) \in \mathbb{C},
\]</span></p>
<p>evaluated at <span class="math inline">\(\nu = \frac{5}{2}\)</span>.</p>
<p>Although <span class="math inline">\(f\)</span> is smooth, we clearly observe <strong>strong oscillations</strong> in <span class="math inline">\(\hat{f}\)</span>, highlighting the influence of the exponential kernel.</p>
<div id="4a23100c" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="dv">5</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>t1 <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">1000</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>t2 <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1000</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> t: np.exp(<span class="op">-</span>t<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> <span class="kw">lambda</span> t: f(t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> t)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>f_vals <span class="op">=</span> f(t1)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>phi_vals <span class="op">=</span> phi(t2)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">7.24</span>, <span class="fl">4.07</span>), dpi<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(t1, f_vals, <span class="st">'k'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlim(<span class="op">-</span><span class="dv">8</span>, <span class="dv">8</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="vs">r"$f(t) = e^{-t^2}$"</span>)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(t2, np.real(phi_vals), <span class="st">'b'</span>, label<span class="op">=</span><span class="vs">r"$\Re(\phi)$"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(t2, np.imag(phi_vals), <span class="st">'r'</span>, label<span class="op">=</span><span class="vs">r"$\Im(\phi)$"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlim(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="vs">r"$\phi(t) = f(t)e^{-2i\pi\nu t}$, $\nu=5/2$"</span>)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].legend()</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-6-output-1.png" width="714" height="394" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>These rapid variations can create difficulties in the <strong>numerical approximation</strong> of the Fourier transform using quadrature methods, even when a large number of points <span class="math inline">\(n\)</span> is used. One way to overcome this issue is by using the <strong>Fast Fourier Transform (FFT)</strong> algorithm.</p>
</section>
</section>
<section id="the-approximation-obtained-using-the-left-rectangle-quadrature-method-is-periodic-in-nature." class="level2">
<h2 class="anchored" data-anchor-id="the-approximation-obtained-using-the-left-rectangle-quadrature-method-is-periodic-in-nature.">The approximation obtained using the left rectangle quadrature method is periodic in nature.</h2>
<p>We observe that even if the function <span class="math inline">\(f\)</span> is <strong>not periodic</strong>, its Fourier transform approximation <span class="math inline">\(\hat{f}\)</span> appears <strong>periodic</strong>. In fact, the function <span class="math inline">\(\hat{S}_n\)</span>, resulting from the quadrature method, is periodic with period</p>
<p><span class="math display">\[
\Delta \nu = \frac{n}{T}.
\]</span> <span class="math display">\[
\forall \nu \in \mathbb{R} \quad
\widehat{S}_n\left(\nu + \frac{n}{T} \right)
= \frac{T}{n} e^{i\pi \nu T} \sum_{k=0}^{n-1} f_k \, e^{-2i\pi\left(\nu + \frac{n}{T} \right)T \frac{k}{n}}
= \frac{T}{n} e^{i\pi \nu T} \sum_{k=0}^{n-1} f_k \, e^{-2i\pi \nu T \frac{k}{n}} \underbrace{e^{-2i\pi k}}_{=1}
\]</span></p>
<p><span class="math display">\[
\phantom{\forall \nu \in \mathbb{R} \quad
\widehat{S}_n\left(\nu + \frac{n}{T} \right)}
= \frac{T}{n} e^{i\pi \nu T} \sum_{k=0}^{n-1} f_k \, e^{-2i\pi \nu T \frac{k}{n}} = \widehat{S}_n(\nu).
\]</span></p>
<p>This periodicity of <span class="math inline">\(\hat{S}_n\)</span> implies that it is <strong>not possible to compute the Fourier transform</strong> for all frequencies <span class="math inline">\(\nu \in \mathbb{R}\)</span> using the quadrature method when the parameters <span class="math inline">\(T\)</span> and <span class="math inline">\(n\)</span> are fixed. In fact, it becomes <strong>impossible to compute <span class="math inline">\(\hat{f}(\nu)\)</span></strong> accurately when</p>
<p><span class="math display">\[
|\nu| \geq \nu_{\text{max}},
\]</span></p>
<p>where <span class="math inline">\(\nu_{\text{max}} = \frac{n}{T}\)</span> is the <strong>maximum frequency</strong> that can be resolved due to the periodic nature of <span class="math inline">\(\hat{S}_n\)</span>.</p>
<p>As a result, in practice, <strong>to compute the Fourier transform for large frequencies</strong>, one must increase either the time window <span class="math inline">\(T\)</span> or the number of points <span class="math inline">\(n\)</span>.</p>
<p>Furthermore, by evaluating the error in approximating <span class="math inline">\(\hat{f}(\nu)\)</span> using the left rectangle quadrature method, we find that the approximation is reliable <strong>at frequency <span class="math inline">\(\nu\)</span></strong> when the following condition holds:</p>
<p><span class="math display">\[
|\nu| \ll \frac{n}{T}
\]</span></p>
<p><span class="math display">\[
\frac{\nu T}{n} \ll 1.
\]</span></p>
<p><span class="citation" data-cites="epstein2005well">Epstein (<a href="#ref-epstein2005well" role="doc-biblioref">2005</a>)</span> shows that when using the <strong>Fast Fourier Transform (FFT)</strong> algorithm, it is possible to accurately compute the Fourier transform of a function <span class="math inline">\(f\)</span> for all frequencies <span class="math inline">\(\nu \in \mathbb{R}\)</span>, even when <span class="math inline">\(\frac{\nu T}{n}\)</span> is close to 1 — provided that <span class="math inline">\(f\)</span> is <strong>piecewise continuous</strong> and has <strong>compact support</strong>.</p>
</section>
<section id="computing-the-fourier-transform-at-frequency-nu-using-the-fft-algorithm." class="level2">
<h2 class="anchored" data-anchor-id="computing-the-fourier-transform-at-frequency-nu-using-the-fft-algorithm.">Computing the Fourier Transform at Frequency <span class="math inline">\(\nu\)</span> Using the FFT Algorithm.</h2>
<p>In this section, we denote by <span class="math inline">\(\hat{S}_n(\nu)\)</span> the approximation of the Fourier transform <span class="math inline">\(\hat{f}(\nu)\)</span> of the function <span class="math inline">\(f\)</span> at a point <span class="math inline">\(\nu \in \left[-\frac{\nu_{\text{max}}}{2}, \frac{\nu_{\text{max}}}{2}\right]\)</span>, where <span class="math inline">\(\nu_{\text{max}} = \frac{n}{T}\)</span>, i.e., <span class="math display">\[
\boxed{
\hat{f}(\nu) \approx \hat{S}_n(\nu) = \frac{T}{n} e^{i\pi \nu T} \sum_{k=0}^{n-1} f_k\, e^{-2 i \pi \nu T k / n}.
}
\]</span></p>
<p>We now present the Fourier transform algorithm used to approximate <span class="math inline">\(\hat{f}(\nu)\)</span>. We will not go into the details of the Fast Fourier Transform (FFT) algorithm in this article. <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> provides a simplified explanation of the FFT, and for more in-depth technical details, we recommend the original article by <span class="citation" data-cites="cooley1965algorithm">Cooley and Tukey (<a href="#ref-cooley1965algorithm" role="doc-biblioref">1965</a>)</span>.</p>
<p>What is important to understand is that the use of the FFT algorithm to approximate the Fourier transform of a function <span class="math inline">\(f\)</span> is based on the result shown by <span class="citation" data-cites="epstein2005well">Epstein (<a href="#ref-epstein2005well" role="doc-biblioref">2005</a>)</span>, which states that when <span class="math inline">\(\hat{S}_n(\nu)\)</span> is evaluated at the frequencies <span class="math inline">\(\nu_j = \frac{j}{T}\)</span> for <span class="math inline">\(j = 0, 1, \dots, n - 1\)</span>, it gives a good approximation of the continuous Fourier transform <span class="math inline">\(\hat{f}(\nu)\)</span>.</p>
<p>Moreover, <span class="math inline">\(\hat{S}_n\)</span> is known to be periodic. This periodicity gives a symmetric role to the indices <span class="math inline">\(j \in \{0, 1, \dots, n - 1\}\)</span> and <span class="math inline">\(k \in \{-\frac{n}{2}, -\frac{n}{2} + 1, \dots, -1\}\)</span>. In fact, the values of the Fourier transform of <span class="math inline">\(f\)</span> over the interval <span class="math inline">\(\left[ -\frac{\nu_{\text{max}}}{2}, \frac{\nu_{\text{max}}}{2} \right]\)</span> can be derived from the values of <span class="math inline">\(\hat{S}_n\)</span> at the points <span class="math inline">\(\nu_j = \frac{j}{T}\)</span>, for <span class="math inline">\(j = 0, 1, \dots, n - 1\)</span>, as follows:</p>
<p><span class="math display">\[
\widehat{S}_n(\nu'_j) = \frac{T}{n} (-1)^j \sum_{k=0}^{n-1} f_k\, e^{-2i\pi j \frac{k}{n}}
=
\begin{cases}
\widehat{S}_n(\nu_j) &amp; \text{si } j \in \left\{0, \dots, \frac{n}{2} - 1 \right\} \\
\widehat{S}_n(\nu_{j-n}) &amp; \text{si } j \in \left\{ \frac{n}{2}, \dots, n-1 \right\}
\end{cases}
\]</span></p>
<p><span class="math display">\[
\text{where&nbsp;we&nbsp;used&nbsp;the&nbsp;relation} \quad
e^{-2i\pi j \frac{k}{n}} = e^{-2i\pi (j-n) \frac{k}{n}} \times \underbrace{e^{-2i\pi k}}_{=1}
= e^{-2i\pi (j-n) \frac{k}{n}}
\quad \text{for } j \in \left\{ \frac{n}{2}, \dots, n-1 \right\}.
\]</span></p>
<p>This relationship shows that we can compute the Fourier transform <span class="math inline">\(\hat{S}_n\left( \frac{j}{T} \right)\)</span> for <span class="math inline">\(j = -\frac{n}{2}, \ldots, \frac{n}{2} - 1\)</span>. Moreover, when <span class="math inline">\(n\)</span> is a power of 2, it can be shown that the computation becomes faster <span class="citation" data-cites="balac2011transformee">(see <a href="#ref-balac2011transformee" role="doc-biblioref">Balac 2011</a>)</span>. This process is known as the Fast Fourier Transform (FFT).</p>
<p>To summarize, we have shown that the Fourier transform of the function <span class="math inline">\(f\)</span> can be approximated over the interval <span class="math inline">\(\left[-\frac{T}{2}, \frac{T}{2}\right]\)</span> at the frequencies <span class="math inline">\(\nu_j = \frac{j}{T}\)</span> for <span class="math inline">\(j = -\frac{n}{2}, \ldots, \frac{n}{2} - 1\)</span>, where <span class="math inline">\(n = 2^m\)</span> for some integer <span class="math inline">\(m \geq 0\)</span>, by applying the FFT algorithm as follows:</p>
<ul>
<li><p>Construct the finite sequence <span class="math inline">\(F\)</span> of values <span class="math inline">\(f\left( \frac{2k - n}{2n} T \right)\)</span> for <span class="math inline">\(k = 0, 1, \ldots, n - 1\)</span>.</p></li>
<li><p>Compute the discrete Fourier transform <span class="math inline">\(\hat{F}\)</span> of the sequence <span class="math inline">\(F\)</span> using the Fast Fourier Transform (FFT) algorithm, which is given by</p>
<p><span class="math display">\[
\hat{F}_j = \sum_{k=0}^{n-1} f_k \, e^{-2i\pi \frac{jk}{n}}, \quad \text{for } j = 0, 1, \ldots, n-1.
\]</span></p></li>
<li><p>Reindex and symmetrize the values to span <span class="math inline">\(j = -\frac{n}{2}, \ldots, -1\)</span>.</p></li>
<li><p>Multiply each value in the array by <span class="math inline">\(\frac{T}{n} (-1)^{j-1}\)</span>, where <span class="math inline">\(j \in \{1, \ldots, n\}\)</span>.</p></li>
</ul>
<p>This yields an array corresponding to the values of the Fourier transform <span class="math inline">\(\hat{f}(\nu_j)\)</span>, with <span class="math inline">\(\nu_j = \frac{j}{T}\)</span> for <span class="math inline">\(j = -\frac{n}{2}, \ldots, \frac{n}{2} - 1\)</span>.</p>
<p>The following Python function <code>tffft</code> implements these steps to compute the Fourier transform of a given function.</p>
<div id="f34d2ae6" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft, fftshift</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tffft(f, T, n):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule la transformée de Fourier approchée d'une fonction f à support dans [-T/2, T/2],</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    en utilisant l’algorithme FFT.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Paramètres</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    ----------</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    f : callable</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">        Fonction à transformer (doit être vectorisable avec numpy).</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co">    T : float</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Largeur de la fenêtre temporelle (intervalle [-T/2, T/2]).</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co">    n : int</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Nombre de points de discrétisation (doit être une puissance de 2 pour FFT efficace).</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Retours</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">    -------</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">    tf : np.ndarray</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Valeurs approximées de la transformée de Fourier aux fréquences discrètes.</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co">    freq_nu : np.ndarray</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Fréquences discrètes correspondantes (de -n/(2T) à (n/2 - 1)/T).</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> T <span class="op">/</span> n</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> T <span class="op">+</span> np.arange(n) <span class="op">*</span> h  <span class="co"># noeuds temporels</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> f(t)                         <span class="co"># échantillonnage de f</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    tf <span class="op">=</span> h <span class="op">*</span> (<span class="op">-</span><span class="dv">1</span>) <span class="op">**</span> np.arange(n) <span class="op">*</span> fftshift(fft(F))  <span class="co"># TF approximée</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    freq_nu <span class="op">=</span> <span class="op">-</span>n <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> T) <span class="op">+</span> np.arange(n) <span class="op">/</span> T              <span class="co"># fréquences ν_j = j/T</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tf, freq_nu, t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The following program illustrates how to compute the Fourier transform of the Gaussian function <span class="math inline">\(f(t) = e^{-10t^2}\)</span> over the interval <span class="math inline">\([-10, 10]\)</span>, using the Fast Fourier Transform (FFT) algorithm.</p>
<div id="1914449c" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> t: np.exp(<span class="op">-</span>a <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">8</span>  <span class="co"># 256</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the Fourier transform using FFT</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>tf, nu, t <span class="op">=</span> tffft(f, T, n)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Plotting</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">7.24</span>, <span class="fl">4.07</span>), dpi<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(t, f(t), <span class="st">'-g'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">"time"</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">"Considered Function"</span>)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylim(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">1.1</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].grid(<span class="va">True</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].plot(nu, np.<span class="bu">abs</span>(tf), <span class="st">'-b'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">"frequency"</span>)</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">"Fourier Transform using FFT"</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlim(<span class="op">-</span><span class="dv">15</span>, <span class="dv">15</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylim(<span class="op">-</span><span class="fl">0.5</span>, <span class="dv">1</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].grid(<span class="va">True</span>)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-8-output-1.png" width="714" height="395" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The method we have just presented allows us to compute and visualize the Fourier transform of a function <span class="math inline">\(f\)</span> at discrete points <span class="math inline">\(\nu_j = \frac{j}{T}\)</span>, for <span class="math inline">\(j = -\frac{n}{2}, \ldots, \frac{n}{2} - 1\)</span>, where <span class="math inline">\(n\)</span> is a power of 2. These points lie within the interval <span class="math inline">\(\left[-\frac{n}{2T}, \frac{n}{2T}\right]\)</span>. However, this approach does not allow us to evaluate the Fourier transform at arbitrary points <span class="math inline">\(\nu\)</span> in the same interval when <span class="math inline">\(\nu\)</span> is not of the form <span class="math inline">\(\nu_j = \frac{j}{T}\)</span>.</p>
<p>To compute the Fourier transform of a function <span class="math inline">\(f\)</span> at a point <span class="math inline">\(\nu\)</span> that does not coincide with one of the sampling frequencies <span class="math inline">\(\nu_j\)</span>, interpolation methods can be used (e.g., linear, polynomial, spline interpolation, etc.). In this article, we adopt the approach proposed by <span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span>, which relies on <strong>Shannon’s interpolation theorem</strong> to compute the Fourier transform of a function <span class="math inline">\(f\)</span> at any point <span class="math inline">\(\nu\)</span>.</p>
</section>
<section id="using-shannons-interpolation-theorem-to-compute-the-fourier-transform-of-a-function-f-at-a-point-nu" class="level2">
<h2 class="anchored" data-anchor-id="using-shannons-interpolation-theorem-to-compute-the-fourier-transform-of-a-function-f-at-a-point-nu">Using Shannon’s Interpolation Theorem to Compute the Fourier Transform of a Function <span class="math inline">\(f\)</span> at a Point <span class="math inline">\(\nu\)</span></h2>
<p>Que nous dit le théorème de Shannon ? Il nous dit que pour une fonction <span class="math inline">\(g\)</span> à bande limitée c’est-à-dire dont la transformée de Fourier <span class="math inline">\(\hat{g}\)</span> est nulle en dehors d’un intervalle <span class="math inline">\([-\frac{B}{2}, \frac{B}{2}]\)</span>, on peut reconstruire la fonction <span class="math inline">\(g\)</span> à partir de ses échantillons <span class="math inline">\(g_k = g\left(\frac{k}{B}\right)\)</span> pour <span class="math inline">\(k \in \mathbb{Z}\)</span>. Si on note <span class="math inline">\(\nu_c\)</span> le plus petit réel positif tel que <span class="math inline">\(\hat{g}\)</span> est nulle en déhors de l’intervalle <span class="math inline">\([-2 \pi \nu_c, 2 \pi \nu_c]\)</span>, alors on a la formule d’interpolation de Shannon : Pour tout <span class="math inline">\(t \in \mathbb{R}\)</span>, et <span class="math inline">\(\alpha\)</span> un réel positif, vérifiant <span class="math inline">\(\alpha \geq \frac{1}{2 \nu_c}\)</span>, on a :</p>
<p><span class="math display">\[
g(t) = \sum_{k \in \mathbb{Z}} g(k\alpha)\, \text{sinc}\left(\frac{\pi}{\alpha}(t - k\alpha)\right)
\]</span></p>
<p>où <span class="math inline">\(\text{sinc}(x) = \frac{\sin(x)}{x}\)</span> est la fonction sinus cardinal sinc.</p>
<p><span class="citation" data-cites="balac2011transformee">Balac (<a href="#ref-balac2011transformee" role="doc-biblioref">2011</a>)</span> montre que lorsque la fonction <span class="math inline">\(f\)</span> est à support borné dans un intervalle <span class="math inline">\([-T/2, T/2]\)</span>, on peut utiliser le théorème d’interpolation de Shannon pour calculer la transformée de Fourier <span class="math inline">\(\hat{f}(\nu)\)</span> pour tout <span class="math inline">\(\nu \in \mathbb{R}\)</span> en utilisant les valeurs de la transformée de Fourier discrète <span class="math inline">\(\hat{S}_n(\nu_j)\)</span> pour <span class="math inline">\(j = -\frac{n}{2}, \ldots, \frac{n}{2} - 1\)</span>. Pour ce faire, il considère <span class="math inline">\(\alpha = \frac{1}{T}\)</span> et obtient pour tout <span class="math inline">\(\nu \in \mathbb{R}\)</span> la formule d’interpolation de Shannon suivante : <span class="math display">\[
\hat{f}(\nu) = \sum_{j=-\frac{n}{2}}^{\frac{n}{2}-1} \hat{S}_n\left(\frac{j}{T}\right)\, \text{sinc}\left(\pi T\left(\nu - \frac{j}{T}\right)\right)
\]</span></p>
<p>Le programme ci-dessous illustre l’utilisation du théorème d’interpolation de Shannon pour calculer la transformée de Fourier d’une fonction <span class="math inline">\(f\)</span> en un point <span class="math inline">\(\nu\)</span>.</p>
<div id="d8e242af" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> shannon(tf, nu, T):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximates the value of the Fourier transform of function f at frequency 'nu'</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">    using its discrete values computed from the FFT.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - tf : numpy array, discrete Fourier transform values (centered with fftshift) at frequencies j/T for j = -n/2, ..., n/2 - 1</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - nu : float, frequency at which to approximate the Fourier transform</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - T  : float, time window width used for the FFT</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - tfnu : approximation of the Fourier transform at frequency 'nu'</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(tf)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    tfnu <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> j <span class="op">-</span> n <span class="op">//</span> <span class="dv">2</span>  <span class="co"># correspond à l'indice j dans {-n/2, ..., n/2 - 1}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        tfnu <span class="op">+=</span> tf[j] <span class="op">*</span> np.sinc(T <span class="op">*</span> nu <span class="op">-</span> k)  <span class="co"># np.sinc(x) = sin(pi x)/(pi x) en numpy</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tfnu</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Enfin, nous pouvons definir la</p>
<div id="9dc31106" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fourier_at_nu(f, T, n, nu):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Fourier transform of f at frequency nu</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">    using tffft + Shannon interpolation.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    tf, _, _ <span class="op">=</span> tffft(f, T, n)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shannon(tf, nu, T)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="46b17d89" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> t: np.exp(<span class="op">-</span>a <span class="op">*</span> np.<span class="bu">abs</span>(t))                          <span class="co"># Fonction à transformer</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>fhat_exact <span class="op">=</span> <span class="kw">lambda</span> nu: (<span class="dv">2</span> <span class="op">*</span> a) <span class="op">/</span> (a<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> np.pi<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> nu<span class="op">**</span><span class="dv">2</span>)  <span class="co"># TF exacte</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">40</span>     <span class="co"># largeur de la fenêtre</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">10</span>  <span class="co"># nombre de points de discrétisation</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul pour nu = 3/T</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="dv">3</span> <span class="op">/</span> T</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Valeur exacte de la TF</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>exact_value <span class="op">=</span> fhat_exact(nu)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximation de la TF en nu </span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>approx_value <span class="op">=</span> fourier_at_nu(f, T, n, nu)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Exact value at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>exact_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Approximation at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>np<span class="sc">.</span>real(approx_value)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul pour nu = pi/T</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> np.pi <span class="op">/</span> T</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Valeur exacte de la TF</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>exact_value <span class="op">=</span> fhat_exact(nu)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximation de la TF en nu</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>approx_value <span class="op">=</span> fourier_at_nu(f, T, n, nu)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Exact value at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>exact_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Approximation at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>np<span class="sc">.</span>real(approx_value)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Exact value at nu=0.075: 2.118347413776218
Approximation at nu=0.075: 2.1185707502943534
Exact value at nu=0.07853981633974483: 2.0262491352594427
Approximation at nu=0.07853981633974483: 2.0264201680784835</code></pre>
</div>
</div>
<p>Une alternative à l’interpolation de Shannon est d’utiliser d’autres méthodes d’interpolation comme l’interpolation de Lagrange ou l’interpolation de Newton.</p>
<div id="9efee06b" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft, fftfreq, fftshift, ifftshift</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> quad</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Define the function and its exact Fourier Transform</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Function f(t) = exp(-πt²)"""</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exact_fourier_transform(nu):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Exact FT of f(t) = exp(-πt²) is also exp(-πν²)"""</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> nu<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Define parameters</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="dv">64</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span>N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(t)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. FFT with SciPy</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>yf_scipy <span class="op">=</span> fftshift(fft(ifftshift(y))) <span class="op">*</span> T</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>xf_scipy <span class="op">=</span> fftshift(fftfreq(N, T))</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. FFT with NumPy</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>yf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fft(np.fft.ifftshift(y))) <span class="op">*</span> T</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>xf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fftfreq(N, T))</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a><span class="co"># 5. Numerical integration method (quadrature)</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tf_integral(f, nu, T):</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Compute FT of f at frequency nu over [-T/2, T/2] using scipy quad."""</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    real_part <span class="op">=</span> quad(<span class="kw">lambda</span> t: np.real(f(t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> t)), <span class="op">-</span>T<span class="op">/</span><span class="dv">2</span>, T<span class="op">/</span><span class="dv">2</span>)[<span class="dv">0</span>]</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    imag_part <span class="op">=</span> quad(<span class="kw">lambda</span> t: np.imag(f(t) <span class="op">*</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> nu <span class="op">*</span> t)), <span class="op">-</span>T<span class="op">/</span><span class="dv">2</span>, T<span class="op">/</span><span class="dv">2</span>)[<span class="dv">0</span>]</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> real_part <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> imag_part</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute values for comparison</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>nu_vals <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">400</span>)</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>FT_exact <span class="op">=</span> exact_fourier_transform(nu_vals)</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>FT_integral <span class="op">=</span> np.array([tf_integral(f, nu, <span class="dv">8</span>) <span class="cf">for</span> nu <span class="kw">in</span> nu_vals])</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Interpolate FFT results for better comparison</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a><span class="co"># (FFT frequencies may not align exactly with nu_vals)</span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>interp_scipy <span class="op">=</span> interp1d(xf_scipy, np.real(yf_scipy), kind<span class="op">=</span><span class="st">'cubic'</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>interp_numpy <span class="op">=</span> interp1d(xf_numpy, np.real(yf_numpy), kind<span class="op">=</span><span class="st">'cubic'</span>, fill_value<span class="op">=</span><span class="st">"extrapolate"</span>)</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a>FT_scipy <span class="op">=</span> interp_scipy(nu_vals)</span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>FT_numpy <span class="op">=</span> interp_numpy(nu_vals)</span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-61"><a href="#cb12-61" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. Plot comparison</span></span>
<span id="cb12-62"><a href="#cb12-62" aria-hidden="true" tabindex="-1"></a><span class="co"># ------------------------------</span></span>
<span id="cb12-63"><a href="#cb12-63" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb12-64"><a href="#cb12-64" aria-hidden="true" tabindex="-1"></a>plt.plot(nu_vals, np.real(FT_exact), <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'Exact FT (Analytical)'</span>)</span>
<span id="cb12-65"><a href="#cb12-65" aria-hidden="true" tabindex="-1"></a>plt.plot(nu_vals, np.real(FT_integral), <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Numerical Integral (quad)'</span>)</span>
<span id="cb12-66"><a href="#cb12-66" aria-hidden="true" tabindex="-1"></a>plt.plot(nu_vals, FT_scipy, <span class="st">'b-.'</span>, linewidth<span class="op">=</span><span class="fl">1.2</span>, label<span class="op">=</span><span class="st">'FFT (SciPy)'</span>)</span>
<span id="cb12-67"><a href="#cb12-67" aria-hidden="true" tabindex="-1"></a>plt.plot(nu_vals, FT_numpy, <span class="st">'g:'</span>, linewidth<span class="op">=</span><span class="fl">1.2</span>, label<span class="op">=</span><span class="st">'FFT (NumPy)'</span>)</span>
<span id="cb12-68"><a href="#cb12-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-69"><a href="#cb12-69" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Comparison of Fourier Transform Methods"</span>, fontsize<span class="op">=</span><span class="dv">13</span>)</span>
<span id="cb12-70"><a href="#cb12-70" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Frequency (ν)"</span>)</span>
<span id="cb12-71"><a href="#cb12-71" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Amplitude (Real part)"</span>)</span>
<span id="cb12-72"><a href="#cb12-72" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb12-73"><a href="#cb12-73" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">1.1</span>)</span>
<span id="cb12-74"><a href="#cb12-74" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, linestyle<span class="op">=</span><span class="st">':'</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb12-75"><a href="#cb12-75" aria-hidden="true" tabindex="-1"></a>plt.legend(frameon<span class="op">=</span><span class="va">False</span>, loc<span class="op">=</span><span class="st">'upper right'</span>)</span>
<span id="cb12-76"><a href="#cb12-76" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb12-77"><a href="#cb12-77" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-12-output-1.png" width="758" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="ea34b5f7" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft, fftfreq, fftshift, ifftshift</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the function f(t) = exp(-pi * t^2)</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(t):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> t<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="dv">64</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="op">-</span>N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N<span class="op">/</span><span class="dv">2</span><span class="op">*</span>T, N, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f(t)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># FFT with scipy</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>yf_scipy <span class="op">=</span> fftshift(fft(ifftshift(y))) <span class="op">*</span> T</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>xf <span class="op">=</span> fftshift(fftfreq(N, T))</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>FT_exact <span class="op">=</span> np.exp(<span class="op">-</span>np.pi <span class="op">*</span> xf<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co"># FFT with numpy</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>yf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fft(np.fft.ifftshift(y))) <span class="op">*</span> T</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>xf_numpy <span class="op">=</span> np.fft.fftshift(np.fft.fftfreq(N, T))</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot with subplot_mosaic</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplot_mosaic([[<span class="st">"scipy"</span>, <span class="st">"numpy"</span>]], figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>), layout<span class="op">=</span><span class="st">"constrained"</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Scipy FFT</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].plot(xf, FT_exact, <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Exact FT'</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].plot(xf, np.real(yf_scipy), <span class="st">'r--'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'FFT (scipy)'</span>)</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_ylim(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_title(<span class="st">"Scipy FFT"</span>)</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_xlabel(<span class="st">"Frequency"</span>)</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].set_ylabel(<span class="st">"Amplitude"</span>)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].legend()</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"scipy"</span>].grid(<span class="va">False</span>)</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a><span class="co"># NumPy FFT</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].plot(xf_numpy, FT_exact, <span class="st">'k-'</span>, linewidth<span class="op">=</span><span class="fl">1.5</span>, label<span class="op">=</span><span class="st">'Exact FT'</span>)</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].plot(xf_numpy, np.real(yf_numpy), <span class="st">'b--'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'FFT (numpy)'</span>)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_xlim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_title(<span class="st">"NumPy FFT"</span>)</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].set_xlabel(<span class="st">"Frequency"</span>)</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].legend()</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>axs[<span class="st">"numpy"</span>].grid(<span class="va">False</span>)</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Comparison of FFT Implementations vs. Exact Fourier Transform"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="1_fourrier_transformation_files/figure-html/cell-13-output-1.png" width="683" height="491" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="computing-the-fourier-transform-at-frequency-ν-using-the-fft-algorithm-in-numpy-and-scipy" class="level1">
<h1>Computing the Fourier Transform at Frequency ν Using the FFT Algorithm in numpy and SciPy</h1>
<div id="1566eee0" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.fft <span class="im">import</span> fft, fftshift, fftfreq, ifftshift</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to compute the Fourier Transform using FFT using SciPy</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fourier_at_nu_scipy(f, T, n, nu):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Computes the Fourier transform of f at frequency nu</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    using scipy's FFT + Shannon interpolation.</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> np.linspace(<span class="op">-</span>T<span class="op">/</span><span class="dv">2</span>, T<span class="op">/</span><span class="dv">2</span>, n, endpoint<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    F <span class="op">=</span> f(t)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    tf <span class="op">=</span> fftshift(fft(ifftshift(F))) <span class="op">*</span> (T<span class="op">/</span>n)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> shannon(tf, nu, T)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">## Example usage</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="kw">lambda</span> t: np.exp(<span class="op">-</span>a <span class="op">*</span> np.<span class="bu">abs</span>(t))                          <span class="co"># function to transform</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>fhat_exact <span class="op">=</span> <span class="kw">lambda</span> nu: (<span class="dv">2</span> <span class="op">*</span> a) <span class="op">/</span> (a<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> np.pi<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> nu<span class="op">**</span><span class="dv">2</span>)  <span class="co"># exact TF</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">40</span>     <span class="co"># window width</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span><span class="op">**</span><span class="dv">10</span>  <span class="co"># number of discretization points</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculation for nu = 3/T</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> <span class="dv">3</span> <span class="op">/</span> T</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Exact value of the TF</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>exact_value <span class="op">=</span> fhat_exact(nu)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximation de la TF en nu</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>approx_value_scipy <span class="op">=</span> fourier_at_nu_scipy(f, T, n</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>, nu)</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Exact value at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>exact_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Approximation (SciPy) at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>np<span class="sc">.</span>real(approx_value_scipy)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculation for nu = pi/T</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> np.pi <span class="op">/</span> T</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Exact value of the TF</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>exact_value <span class="op">=</span> fhat_exact(nu)</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Approximation de la TF en nu</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>approx_value_scipy <span class="op">=</span> fourier_at_nu_scipy(f, T, n, nu)</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Exact value at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>exact_value<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Approximation (SciPy) at nu=</span><span class="sc">{</span>nu<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>np<span class="sc">.</span>real(approx_value_scipy)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Exact value at nu=0.075: 2.118347413776218
Approximation (SciPy) at nu=0.075: 2.1185707502943534
Exact value at nu=0.07853981633974483: 2.0262491352594427
Approximation (SciPy) at nu=0.07853981633974483: 2.0264201680784835</code></pre>
</div>
</div>



</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-balac2011transformee" class="csl-entry" role="listitem">
Balac, Stéphane. 2011. <span>“La Transform<span>é</span>e de Fourier Vue Sous l’angle Du Calcul Num<span>é</span>rique.”</span>
</div>
<div id="ref-cooley1965algorithm" class="csl-entry" role="listitem">
Cooley, James W, and John W Tukey. 1965. <span>“An Algorithm for the Machine Calculation of Complex Fourier Series.”</span> <em>Mathematics of Computation</em> 19 (90): 297–301.
</div>
<div id="ref-el2013parametric" class="csl-entry" role="listitem">
El Kolei, Salima. 2013. <span>“Parametric Estimation of Hidden Stochastic Model by Contrast Minimization and Deconvolution: Application to the Stochastic Volatility Model.”</span> <em>Metrika</em> 76 (8): 1031–81.
</div>
<div id="ref-epstein2005well" class="csl-entry" role="listitem">
Epstein, Charles L. 2005. <span>“How Well Does the Finite Fourier Transform Approximate the Fourier Transform?”</span> <em>Communications on Pure and Applied Mathematics: A Journal Issued by the Courant Institute of Mathematical Sciences</em> 58 (10): 1421–35.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>